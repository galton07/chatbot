import async from 'async';
import _ from 'lodash';
import util from 'util';
import require$$0 from 'debug';
import isJson from 'is-json';
import xlsx from 'xlsx';
import fs from 'fs';
import path from 'path';
import glob from 'glob';
import child_process from 'child_process';
import mkdirp from 'mkdirp';
import rimraf from 'rimraf';
import socket from 'socket.io-client';
import randomatic from 'randomatic';
import slug from 'slug';
import tcpPortUsed from 'tcp-port-used';
import findRoot from 'find-root';
import request from 'request';
import copyDir from 'copy-dir';
import dgram from 'dgram';
import events from 'events';
import writeYaml from 'write-yaml';
import mustache from 'mustache';
import facebookChatApi from 'facebook-chat-api';
import v1 from 'watson-developer-cloud/conversation/v1';
import jsonpath from 'jsonpath';
import opn from 'opn';
import tinyServer from 'tiny-server';
import socket$1 from 'socket.io';
import moment from 'moment';

var Capabilities = {
  PROJECTNAME: 'PROJECTNAME',
  TEMPDIR: 'TEMPDIR',
  CLEANUPTEMPDIR: 'CLEANUPTEMPDIR',
  WAITFORBOTTIMEOUT: 'WAITFORBOTTIMEOUT',
  // "docker" "fbdirect" "watsonconversation", "simplerest", "webspeech", "inprocess"
  CONTAINERMODE: 'CONTAINERMODE',
  STARTCMD: 'STARTCMD',
  DOCKERCOMPOSEPATH: 'DOCKERCOMPOSEPATH',
  DOCKERMACHINEPATH: 'DOCKERMACHINEPATH',
  DOCKERMACHINE: 'DOCKERMACHINE',
  DOCKERIMAGE: 'DOCKERIMAGE',
  DOCKERUNIQUECONTAINERNAMES: 'DOCKERUNIQUECONTAINERNAMES',
  DOCKERSYSLOGPORT: 'DOCKERSYSLOGPORT',
  DOCKERSYSLOGPORT_RANGE: 'DOCKERSYSLOGPORT_RANGE',
  BOTIUMGRIDURL: 'BOTIUMGRIDURL',
  BOTIUMAPITOKEN: 'BOTIUMAPITOKEN',
  BOTIUMGRIDSLOT: 'BOTIUMGRIDSLOT',
  // Facebook Mocker Settings
  FACEBOOK_API: 'FACEBOOK_API',
  FACEBOOK_WEBHOOK_PORT: 'FACEBOOK_WEBHOOK_PORT',
  FACEBOOK_WEBHOOK_PATH: 'FACEBOOK_WEBHOOK_PATH',
  FACEBOOK_PUBLISHPORT: 'FACEBOOK_PUBLISHPORT',
  FACEBOOK_PUBLISHPORT_RANGE: 'FACEBOOK_PUBLISHPORT_RANGE',
  FACEBOOK_SEND_DELIVERY_CONFIRMATION: 'FACEBOOK_SEND_DELIVERY_CONFIRMATION',
  // Slack Mocker Settings
  SLACK_API: 'SLACK_API',
  SLACK_EVENT_PORT: 'SLACK_EVENT_PORT',
  SLACK_EVENT_PATH: 'SLACK_EVENT_PATH',
  SLACK_OAUTH_PORT: 'SLACK_OAUTH_PORT',
  SLACK_OAUTH_PATH: 'SLACK_OAUTH_PATH',
  SLACK_PUBLISHPORT: 'SLACK_PUBLISHPORT',
  SLACK_PUBLISHPORT_RANGE: 'SLACK_PUBLISHPORT_RANGE',
  // Facebook Direct API Settings
  FB_PAGEID: 'FB_PAGEID',
  FB_USER: 'FB_USER',
  FB_PASSWORD: 'FB_PASSWORD',
  // Bot Framework Mocker Settings
  BOTFRAMEWORK_API: 'BOTFRAMEWORK_API',
  BOTFRAMEWORK_APP_ID: 'BOTFRAMEWORK_APP_ID',
  BOTFRAMEWORK_CHANNEL_ID: 'BOTFRAMEWORK_CHANNEL_ID',
  BOTFRAMEWORK_WEBHOOK_PORT: 'BOTFRAMEWORK_WEBHOOK_PORT',
  BOTFRAMEWORK_WEBHOOK_PATH: 'BOTFRAMEWORK_WEBHOOK_PATH',
  BOTFRAMEWORK_PUBLISHPORT: 'BOTFRAMEWORK_PUBLISHPORT',
  BOTFRAMEWORK_PUBLISHPORT_RANGE: 'BOTFRAMEWORK_PUBLISHPORT_RANGE',
  // Watson Conversation Settings
  WATSONCONVERSATION_URL: 'WATSONCONVERSATION_URL',
  WATSONCONVERSATION_VERSION_DATE: 'WATSONCONVERSATION_VERSION_DATE',
  WATSONCONVERSATION_USER: 'WATSONCONVERSATION_USER',
  WATSONCONVERSATION_PASSWORD: 'WATSONCONVERSATION_PASSWORD',
  WATSONCONVERSATION_WORKSPACE_ID: 'WATSONCONVERSATION_WORKSPACE_ID',
  WATSONCONVERSATION_COPY_WORKSPACE: 'WATSONCONVERSATION_COPY_WORKSPACE',
  WATSONCONVERSATION_USE_INTENT: 'WATSONCONVERSATION_USE_INTENT',
  // Simple Reset Bot Settings
  SIMPLEREST_INIT_CONTEXT: 'SIMPLEREST_INIT_CONTEXT',
  SIMPLEREST_INIT_TEXT: 'SIMPLEREST_INIT_TEXT',
  SIMPLEREST_URL: 'SIMPLEREST_URL',
  SIMPLEREST_METHOD: 'SIMPLEREST_METHOD',
  SIMPLEREST_HEADERS_TEMPLATE: 'SIMPLEREST_HEADERS_TEMPLATE',
  SIMPLEREST_BODY_TEMPLATE: 'SIMPLEREST_BODY_TEMPLATE',
  SIMPLEREST_BODY_RAW: 'SIMPLEREST_BODY_RAW',
  SIMPLEREST_RESPONSE_JSONPATH: 'SIMPLEREST_RESPONSE_JSONPATH',
  SIMPLEREST_CONTEXT_JSONPATH: 'SIMPLEREST_CONTEXT_JSONPATH',
  // Webspeech Settings
  WEBSPEECH_SERVER_PORT: 'WEBSPEECH_SERVER_PORT',
  WEBSPEECH_LANGUAGE: 'WEBSPEECH_LANGUAGE',
  WEBSPEECH_PITCH: 'WEBSPEECH_PITCH',
  WEBSPEECH_RATE: 'WEBSPEECH_RATE',
  WEBSPEECH_VOLUME: 'WEBSPEECH_VOLUME',
  WEBSPEECH_VOICE: 'WEBSPEECH_VOICE',
  WEBSPEECH_CLOSEBROWSER: 'WEBSPEECH_CLOSEBROWSER',
  WEBSPEECH_BROWSER_APP: 'WEBSPEECH_BROWSER_APP',
  // Script Compiler
  SCRIPTING_TXT_EOL: 'SCRIPTING_TXT_EOL',
  SCRIPTING_XLSX_STARTROW: 'SCRIPTING_XLSX_STARTROW',
  SCRIPTING_XLSX_STARTCOL: 'SCRIPTING_XLSX_STARTCOL',
  SCRIPTING_XLSX_SHEETNAMES: 'SCRIPTING_XLSX_SHEETNAMES',
  SCRIPTING_XLSX_SHEETNAMES_UTTERANCES: 'SCRIPTING_XLSX_SHEETNAMES_UTTERANCES',
  SCRIPTING_NORMALIZE_TEXT: 'SCRIPTING_NORMALIZE_TEXT',
  // regexp, include, includeLowerCase, equals
  SCRIPTING_MATCHING_MODE: 'SCRIPTING_MATCHING_MODE'
};

var Source = {
  LOCALPATH: 'LOCALPATH',
  GITPATH: 'GITPATH',
  GITURL: 'GITURL',
  GITBRANCH: 'GITBRANCH',
  GITDIR: 'GITDIR',
  GITPREPARECMD: 'GITPREPARECMD'
};

var obj, obj$1;

var Defaults = {
  Capabilities: ( obj = {}, obj[Capabilities.PROJECTNAME] = 'defaultproject', obj[Capabilities.TEMPDIR] = 'botiumwork', obj[Capabilities.CLEANUPTEMPDIR] = true, obj[Capabilities.WAITFORBOTTIMEOUT] = 10000, obj[Capabilities.DOCKERCOMPOSEPATH] = 'docker-compose', obj[Capabilities.DOCKERMACHINEPATH] = 'docker-machine', obj[Capabilities.DOCKERMACHINE] = false, obj[Capabilities.DOCKERIMAGE] = 'node:boron', obj[Capabilities.DOCKERUNIQUECONTAINERNAMES] = false, obj[Capabilities.DOCKERSYSLOGPORT_RANGE] = '47100-47299', obj[Capabilities.SLACK_PUBLISHPORT_RANGE] = '46100-46299', obj[Capabilities.FACEBOOK_PUBLISHPORT_RANGE] = '46300-46499', obj[Capabilities.FACEBOOK_SEND_DELIVERY_CONFIRMATION] = true, obj[Capabilities.BOTFRAMEWORK_PUBLISHPORT_RANGE] = '46500-46699', obj[Capabilities.BOTFRAMEWORK_WEBHOOK_PORT] = 3978, obj[Capabilities.BOTFRAMEWORK_WEBHOOK_PATH] = 'api/messages', obj[Capabilities.BOTFRAMEWORK_CHANNEL_ID] = 'facebook', obj[Capabilities.WATSONCONVERSATION_URL] = 'https://gateway.watsonplatform.net/conversation/api', obj[Capabilities.WATSONCONVERSATION_VERSION_DATE] = '2017-05-26', obj[Capabilities.WATSONCONVERSATION_COPY_WORKSPACE] = false, obj[Capabilities.WATSONCONVERSATION_USE_INTENT] = false, obj[Capabilities.SIMPLEREST_METHOD] = 'GET', obj[Capabilities.WEBSPEECH_SERVER_PORT] = 46050, obj[Capabilities.WEBSPEECH_LANGUAGE] = 'en-US', obj[Capabilities.WEBSPEECH_CLOSEBROWSER] = true, obj[Capabilities.SCRIPTING_TXT_EOL] = '\n', obj[Capabilities.SCRIPTING_XLSX_STARTROW] = 1, obj[Capabilities.SCRIPTING_XLSX_STARTCOL] = 'A', obj[Capabilities.SCRIPTING_NORMALIZE_TEXT] = true, obj[Capabilities.SCRIPTING_MATCHING_MODE] = 'includeLowerCase', obj ),
  Sources: ( obj$1 = {}, obj$1[Source.LOCALPATH] = '.', obj$1[Source.GITPATH] = 'git', obj$1[Source.GITBRANCH] = 'master', obj$1[Source.GITDIR] = '.', obj$1 ),
  Envs: {
    'IS_BOTIUM_CONTAINER': true
  }
};

var Fluent_1 = (function () {
  function Fluent (driver) {
  var this$1 = this;

    this.driver = driver;
    this.compiler = null;
    this.container = null;
    this.currentChannel = null;
    this.tasks = [];

    this.tasks.push(function () {
      return new Promise(function (resolve, reject) {
        this$1.driver.Build()
          .then(function (container) {
            this$1.container = container;
            resolve();
          })
          .catch(function (err) {
            reject(err);
          });
      })
    });
  }

  Fluent.prototype.Exec = function Exec () {
    var this$1 = this;

    return new Promise(function (resolve, reject) {
      async.eachSeries(this$1.tasks, function (task, cb) {
        task().then(function () { return cb(); }).catch(cb);
      }, function (err) {
        if (err) { return reject(err) }
        resolve();
      });
    })
  };

  Fluent.prototype.Start = function Start () {
    var this$1 = this;

    this.tasks.push(function () {
      return this$1.container.Start()
    });
    return this
  };

  Fluent.prototype.SwitchChannel = function SwitchChannel (channel) {
    var this$1 = this;

    this.tasks.push(function () {
      this$1.currentChannel = channel;
      return Promise.resolve()
    });
    return this
  };

  Fluent.prototype.ReadScripts = function ReadScripts (scriptDir) {
    var this$1 = this;

    this.tasks.push(function () {
      return new Promise(function (resolve, reject) {
        if (this$1.compiler == null) {
          try {
            this$1.compiler = this$1.driver.BuildCompiler();
          } catch (err) {
            return reject(err)
          }
        }
        try {
          this$1.compiler.ReadScriptsFromDirectory(scriptDir);
          resolve();
        } catch (err) {
          reject(err);
        }
      })
    });
    return this
  };

  Fluent.prototype.Compile = function Compile (scriptBuffer, scriptFormat, scriptType) {
    var this$1 = this;

    this.tasks.push(function () {
      return new Promise(function (resolve, reject) {
        if (this$1.compiler == null) {
          try {
            this$1.compiler = this$1.driver.BuildCompiler();
          } catch (err) {
            return reject(err)
          }
        }
        try {
          this$1.compiler.Compile(scriptBuffer, scriptFormat, scriptType);
          resolve();
        } catch (err) {
          reject(err);
        }
      })
    });
    return this
  };

  Fluent.prototype.RunScripts = function RunScripts (assertCb, failCb) {
    var this$1 = this;

    this.tasks.push(function () {
      return new Promise(function (resolve, reject) {
        if (assertCb) {
          this$1.compiler.scriptingEvents.assertBotResponse = assertCb.bind(this$1.compiler);
        }
        if (failCb) {
          this$1.compiler.scriptingEvents.fail = failCb.bind(this$1.compiler);
        }

        this$1.compiler.ExpandConvos();

        async.eachSeries(this$1.compiler.convos, function (convo, convoDone) {
          convo.Run(this$1.container).then(function () { return convoDone(); }).catch(convoDone);
        },
        function (err) {
          if (err) { return reject(err) }
          else { resolve(); }
        });
      })
    });
    return this
  };

  Fluent.prototype.UserSaysText = function UserSaysText (msg) {
    var this$1 = this;

    this.tasks.push(function () {
      if (this$1.currentChannel) {
        return this$1.container.UserSays({ messageText: msg, channel: this$1.currentChannel })
      } else {
        return this$1.container.UserSaysText(msg)
      }
    });
    return this
  };

  Fluent.prototype.UserSays = function UserSays (msg) {
    var this$1 = this;

    this.tasks.push(function () {
      if (this$1.currentChannel && !msg.channel) {
        msg = Object.assign({}, msg);
        msg.channel = this$1.currentChannel;
      }
      return this$1.container.UserSays(msg)
    });
    return this
  };

  Fluent.prototype.WaitBotSays = function WaitBotSays (channel, timeoutMillis, callback) {
    var this$1 = this;
    if ( channel === void 0 ) channel = null;
    if ( timeoutMillis === void 0 ) timeoutMillis = null;
    if ( callback === void 0 ) callback = null;

    if (!callback) {
      if (timeoutMillis && _.isFunction(timeoutMillis)) {
        callback = timeoutMillis;
        timeoutMillis = null;
      } else if (!timeoutMillis && channel && _.isFunction(channel)) {
        callback = channel;
        timeoutMillis = null;
        channel = null;
      }
    }

    this.tasks.push(function () {
      return new Promise(function (resolve, reject) {
        if (this$1.currentChannel && !channel) {
          channel = this$1.currentChannel;
        }
        this$1.container.WaitBotSays(channel, timeoutMillis)
          .then(function (botMsg) {
            if (callback) { callback(botMsg); }
            resolve();
          })
          .catch(function (err) {
            reject(err);
          });
      })
    });
    return this
  };

  Fluent.prototype.WaitBotSaysText = function WaitBotSaysText (channel, timeoutMillis, callback) {
    var this$1 = this;
    if ( channel === void 0 ) channel = null;
    if ( timeoutMillis === void 0 ) timeoutMillis = null;
    if ( callback === void 0 ) callback = null;

    if (!callback) {
      if (timeoutMillis && _.isFunction(timeoutMillis)) {
        callback = timeoutMillis;
        timeoutMillis = null;
      } else if (!timeoutMillis && channel && _.isFunction(channel)) {
        callback = channel;
        timeoutMillis = null;
        channel = null;
      }
    }

    this.tasks.push(function () {
      return new Promise(function (resolve, reject) {
        if (this$1.currentChannel && !channel) {
          channel = this$1.currentChannel;
        }
        this$1.container.WaitBotSaysText(channel, timeoutMillis)
          .then(function (text) {
            if (callback) { callback(text); }
            resolve();
          })
          .catch(function (err) {
            reject(err);
          });
      })
    });
    return this
  };

  Fluent.prototype.Restart = function Restart () {
    var this$1 = this;

    this.tasks.push(function () {
      return this$1.container.Restart()
    });
    return this
  };

  Fluent.prototype.Stop = function Stop () {
    var this$1 = this;

    this.tasks.push(function () {
      return this$1.container.Stop()
    });
    return this
  };

  Fluent.prototype.Clean = function Clean () {
    var this$1 = this;

    this.tasks.push(function () {
      return this$1.container.Clean()
    });
    return this
  };

  return Fluent;
}());

var Events = {
  // Botium Events
  CONTAINER_BUILDING: 'CONTAINER_BUILDING',
  CONTAINER_BUILT: 'CONTAINER_BUILT',
  CONTAINER_BUILD_ERROR: 'CONTAINER_BUILD_ERROR',
  CONTAINER_STARTING: 'CONTAINER_STARTING',
  CONTAINER_STARTED: 'CONTAINER_STARTED',
  CONTAINER_START_ERROR: 'CONTAINER_START_ERROR',
  CONTAINER_STOPPING: 'CONTAINER_STOPPING',
  CONTAINER_STOPPED: 'CONTAINER_STOPPED',
  CONTAINER_STOP_ERROR: 'CONTAINER_STOP_ERROR',
  CONTAINER_CLEANING: 'CONTAINER_CLEANING',
  CONTAINER_CLEANED: 'CONTAINER_CLEANED',
  CONTAINER_CLEAN_ERROR: 'CONTAINER_CLEAN_ERROR',
  BOT_CONNECTED: 'BOT_CONNECTED',
  // Chatbot Events
  MESSAGE_SENTTOBOT: 'MESSAGE_SENTTOBOT',
  MESSAGE_SENDTOBOT_ERROR: 'MESSAGE_SENDTOBOT_ERROR',
  MESSAGE_RECEIVEDFROMBOT: 'MESSAGE_RECEIVEDFROMBOT',
  MESSAGE_RECEIVEFROMBOT_ERROR: 'MESSAGE_RECEIVEFROMBOT_ERROR',
  // Botium Agent Events
  TOOMUCHWORKERS_ERROR: 'TOOMUCHWORKERS_ERROR'
};

var Constants = {
  SCRIPTING_FORMAT_XSLX: 'SCRIPTING_FORMAT_XSLX',
  SCRIPTING_FORMAT_TXT: 'SCRIPTING_FORMAT_TXT',
  SCRIPTING_FORMAT_YAML: 'SCRIPTING_FORMAT_YAML',
  SCRIPTING_TYPE_CONVO: 'SCRIPTING_TYPE_CONVO',
  SCRIPTING_TYPE_UTTERANCES: 'SCRIPTING_TYPE_UTTERANCES'
};

var BotiumMockMessage_1 = (function () {
  function BotiumMockMessage (fromJson) {
  if ( fromJson === void 0 ) fromJson = {};

    this.sender = fromJson.sender;
    this.channel = fromJson.channel;
    this.messageText = fromJson.messageText;
    this.sourceData = fromJson.sourceData;
    this.sourceAction = fromJson.sourceAction;
  }

  return BotiumMockMessage;
}());

var debug = require$$0('botium-Convo');




var ConvoHeader = function ConvoHeader (fromJson) {
  if ( fromJson === void 0 ) fromJson = {};

  this.name = fromJson.name;
  this.order = fromJson.order;
  this.description = fromJson.description;
};

ConvoHeader.prototype.toString = function toString () { return this.order + ' ' + this.name + (this.description ? (" (" + (this.description) + ")") : '') };

var ConvoStep = function ConvoStep (fromJson) {
  if ( fromJson === void 0 ) fromJson = {};

  this.sender = fromJson.sender;
  this.channel = fromJson.channel;
  this.messageText = fromJson.messageText;
  this.sourceData = fromJson.sourceData;
  this.stepTag = fromJson.stepTag;
  this.not = fromJson.not;
};

ConvoStep.prototype.toString = function toString () { return this.stepTag + ': #' + this.sender + ' - ' + (this.not ? '!' : '') + this.messageText };

var Convo = function Convo (provider, fromJson) {
  if ( fromJson === void 0 ) fromJson = {};

  this.provider = provider;
  this.header = new ConvoHeader(fromJson.header);
  if (fromJson.conversation && _.isArray(fromJson.conversation)) {
    this.conversation = _.map(fromJson.conversation, function (step) { return new ConvoStep(step); });
  } else {
    this.conversation = [];
  }
  this.sourceTag = fromJson.sourceTag;
};

Convo.prototype.toString = function toString () { return this.header.toString() + (this.sourceTag ? (" (" + (this.sourceTag) + ")") : '') + ': ' + this.conversation.map(function (c) { return c.toString(); }).join(' | ') };

Convo.prototype.Run = function Run (container) {
    var this$1 = this;

  return new Promise(function (resolve, reject) {
    async.eachSeries(this$1.conversation,
      function (convoStep, convoStepDone) {
        if (convoStep.sender === 'me') {
          convoStep.messageText = this$1._checkNormalizeText(container, convoStep.messageText);
          debug(((this$1.header.name) + "/" + (convoStep.stepTag) + ": user says " + (util.inspect(convoStep))));
          container.UserSays(new BotiumMockMessage_1(convoStep))
            .then(function () { return convoStepDone(); })
            .catch(function (err) {
              convoStepDone(new Error(((this$1.header.name) + "/" + (convoStep.stepTag) + ": error sending to bot " + (util.inspect(err)))));
            });
        } else if (convoStep.sender === 'bot') {
          debug(((this$1.header.name) + " wait for bot " + (util.inspect(convoStep.channel))));
          container.WaitBotSays(convoStep.channel).then(function (saysmsg) {
            debug(((this$1.header.name) + ": bot says " + (util.inspect(saysmsg))));
            if (!saysmsg || (!saysmsg.messageText && !saysmsg.sourceData)) {
              try {
                this$1.provider.scriptingEvents.fail(((this$1.header.name) + "/" + (convoStep.stepTag) + ": bot says nothing"));
              } catch (err) {
                convoStepDone(err);
              }
            } else if (convoStep.messageText) {
              var response = this$1._checkNormalizeText(container, saysmsg.messageText);
              var tomatch = this$1._checkNormalizeText(container, convoStep.messageText);
              if (convoStep.not) {
                try {
                  this$1.provider.scriptingEvents.assertBotNotResponse(response, tomatch, ((this$1.header.name) + "/" + (convoStep.stepTag)));
                  convoStepDone();
                } catch (err) {
                  convoStepDone(err);
                }
              } else {
                try {
                  this$1.provider.scriptingEvents.assertBotResponse(response, tomatch, ((this$1.header.name) + "/" + (convoStep.stepTag)));
                  convoStepDone();
                } catch (err) {
                  convoStepDone(err);
                }
              }
            } else if (convoStep.sourceData) {
              try {
                this$1._compareObject(container, convoStep, saysmsg.sourceData, convoStep.sourceData);
                convoStepDone();
              } catch (err) {
                convoStepDone(err);
              }
            } else {
              convoStepDone();
            }
          }).catch(function (err) {
            try {
              this$1.provider.scriptingEvents.fail(((this$1.header.name) + "/" + (convoStep.stepTag) + ": error waiting for bot " + (util.inspect(err))));
            } catch (err) {
              convoStepDone(err);
            }
          });
        } else {
          try {
            this$1.provider.scriptingEvents.fail(((this$1.header.name) + "/" + (convoStep.stepTag) + ": invalid sender " + (util.inspect(convoStep.sender))));
          } catch (err) {
            convoStepDone(err);
          }
        }
      },
      function (err) {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
  })
};

Convo.prototype._compareObject = function _compareObject (container, convoStep, result, expected) {
    var this$1 = this;

  if (expected === null || expected === undefined) { return }

  if (_.isArray(expected)) {
    if (!_.isArray(result)) {
      throw new Error(((this.header.name) + "/" + (convoStep.stepTag) + ": bot response expected array, got \"" + result + "\""))
    }
    if (expected.length !== result.length) {
      throw new Error(((this.header.name) + "/" + (convoStep.stepTag) + ": bot response expected array length " + (expected.length) + ", got " + (result.length)))
    }
    for (var i = 0; i < expected.length; i++) {
      this$1._compareObject(container, convoStep, result[i], expected[i]);
    }
  } else if (_.isObject(expected)) {
    _.forOwn(expected, function (value, key) {
      if (result.hasOwnProperty(key)) {
        this$1._compareObject(container, convoStep, result[key], expected[key]);
      } else {
        throw new Error(((this$1.header.name) + "/" + (convoStep.stepTag) + ": bot response \"" + result + "\" missing expected property: " + key))
      }
    });
  } else {
    var response = this._checkNormalizeText(container, result);
    var tomatch = this._checkNormalizeText(container, expected);
    this.provider.scriptingEvents.assertBotResponse(response, tomatch, ((this.header.name) + "/" + (convoStep.stepTag)));
  }
};

Convo.prototype._checkNormalizeText = function _checkNormalizeText (container, str) {
  if (str && !_.isString(str)) {
    if (str.toString) { str = str.toString(); }
    else { str = "" + str; }
  }
  if (str && container.caps[Capabilities.SCRIPTING_NORMALIZE_TEXT]) {
    // remove html tags
    str = str.replace(/<p[^>]*>/g, ' ');
    str = str.replace(/<\/p>/g, ' ');
    str = str.replace(/<br[^>]*>/g, ' ');
    str = str.replace(/<[^>]*>/g, '');
    /* eslint-disable no-control-regex */
    // remove not printable characters
    str = str.replace(/[\x00-\x1F\x7F]/g, ' ');
    /* eslint-enable no-control-regex */
    // replace html entities
    str = str
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&#39;/g, "'")
      .replace(/&quot;/g, '"');
    // replace two spaces with one
    str = str.replace(/\s+/g, ' ');

    str = str.trim();
  }
  return str
};

var Convo_1 = {
  ConvoHeader: ConvoHeader,
  Convo: Convo,
  ConvoStep: ConvoStep
};

var CompilerBase_1 = (function () {
  function CompilerBase (provider, caps) {
  if ( caps === void 0 ) caps = {};

    this.provider = provider;
    this.caps = caps;
  }

  CompilerBase.prototype.Validate = function Validate () {
  };

  CompilerBase.prototype.GetHeaders = function GetHeaders (scriptBuffer) {
    var convos = this.Compile(scriptBuffer);
    if (convos) {
      return convos.map(function (convo) { return convo.header; })
    } else {
      return []
    }
  };

  CompilerBase.prototype.Compile = function Compile (scriptBuffer, scriptType) {
    throw new Error("not implemented")
  };

  CompilerBase.prototype.Decompile = function Decompile (convos) {
    throw new Error("not implemented")
  };

  CompilerBase.prototype._AssertCapabilityExists = function _AssertCapabilityExists (cap) {
    if (!this.caps[cap]) {
      throw new Error(("Capability property " + cap + " not set"))
    }
  };

  return CompilerBase;
}());

var Utterance_1 = (function () {
  function Utterance (fromJson) {
  if ( fromJson === void 0 ) fromJson = {};

    this.name = fromJson.name;
    this.utterances = [];
    if (fromJson.utterances && _.isArray(fromJson.utterances)) {
      this.utterances = fromJson.utterances;
    } else if (fromJson.utterances) {
      this.utterances.push(fromJson.utterances);
    }
  }

  Utterance.prototype.toString = function toString () { return this.name + ': ' + this.utterances.join('|') };

  return Utterance;
}());

var debug$1 = require$$0('botium-CompilerXlsx');





var Convo$1 = Convo_1.Convo;

var CompilerXlsx_1 = (function (CompilerBase) {
  function CompilerXlsx (provider, caps) {
    if ( caps === void 0 ) caps = {};

    CompilerBase.call(this, provider, caps);

    this.colnames = [ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' ];
  }

  if ( CompilerBase ) CompilerXlsx.__proto__ = CompilerBase;
  CompilerXlsx.prototype = Object.create( CompilerBase && CompilerBase.prototype );
  CompilerXlsx.prototype.constructor = CompilerXlsx;

  CompilerXlsx.prototype.Validate = function Validate () {
    var this$1 = this;

    CompilerBase.prototype.Validate.call(this);
    this._AssertCapabilityExists(Capabilities.SCRIPTING_XLSX_STARTROW);
    this._AssertCapabilityExists(Capabilities.SCRIPTING_XLSX_STARTCOL);

    if (_.isString(this.caps[Capabilities.SCRIPTING_XLSX_STARTCOL]) && this.colnames.findIndex(function (c) { return c === this$1.caps[Capabilities.SCRIPTING_XLSX_STARTCOL]; }) < 0) {
      throw new Error(("SCRIPTING_XLSX_STARTCOL " + (this.caps[Capabilities.SCRIPTING_XLSX_STARTCOL]) + " invalid (A-Z)"))
    } else if (this.caps[Capabilities.SCRIPTING_XLSX_STARTCOL] < 1 || this.caps[Capabilities.SCRIPTING_XLSX_STARTCOL] > this.colnames.length) {
      throw new Error(("SCRIPTING_XLSX_STARTCOL " + (this.caps[Capabilities.SCRIPTING_XLSX_STARTCOL]) + " invalid (1-" + (this.colnames.length) + ")"))
    }
  };

  CompilerXlsx.prototype.Compile = function Compile (scriptBuffer, scriptType) {
    var this$1 = this;
    if ( scriptType === void 0 ) scriptType = Constants.SCRIPTING_TYPE_CONVO;

    var workbook = xlsx.read(scriptBuffer, { type: 'buffer' });
    if (!workbook) { throw new Error("Workbook not readable") }

    var sheetnames = [];
    if (scriptType === Constants.SCRIPTING_TYPE_CONVO) {
      if (this.caps[Capabilities.SCRIPTING_XLSX_SHEETNAMES]) {
        sheetnames = this.caps[Capabilities.SCRIPTING_XLSX_SHEETNAMES].split(/\s*[;,\s|]\s*/) || [];
      } else {
        sheetnames = workbook.SheetNames || [];
      }
    } else if (scriptType === Constants.SCRIPTING_TYPE_UTTERANCES) {
      if (this.caps[Capabilities.SCRIPTING_XLSX_SHEETNAMES_UTTERANCES]) {
        sheetnames = this.caps[Capabilities.SCRIPTING_XLSX_SHEETNAMES_UTTERANCES].split(/\s*[;,\s|]\s*/) || [];
      } else {
        sheetnames = workbook.SheetNames || [];
      }
    }
    debug$1(("sheet names for " + scriptType + ": " + (util.inspect(sheetnames))));

    var scriptResults = [];

    sheetnames.forEach(function (sheetname) {
      var sheet = workbook.Sheets[sheetname];
      if (!sheet) { return }

      var rowindex = this$1.caps[Capabilities.SCRIPTING_XLSX_STARTROW];
      var colindex = this$1.caps[Capabilities.SCRIPTING_XLSX_STARTCOL] - 1;
      if (_.isString(this$1.caps[Capabilities.SCRIPTING_XLSX_STARTCOL])) {
        colindex = this$1.colnames.findIndex(function (c) { return c === this$1.caps[Capabilities.SCRIPTING_XLSX_STARTCOL]; });
      }
      debug$1(("evaluating sheet name for " + scriptType + ": " + (util.inspect(sheetname)) + ", rowindex " + rowindex + ", colindex " + colindex));

      if (scriptType === Constants.SCRIPTING_TYPE_CONVO) {
        var parseCell = function (content) {
          if (!content) { return {} }

          if (!_.isString(content)) { content = '' + content; }

          var not = false;
          if (content.startsWith('!')) {
            not = true;
            content = content.substr(1);
          }
          if (isJson(content)) {
            return { not: not, sourceData: JSON.parse(content) }
          } else {
            return { not: not, messageText: content }
          }
        };

        var currentConvo = [];
        var emptylines = 0;
        var startcell = null;
        while (true) {
          var meCell = this$1.colnames[colindex] + rowindex;
          var botCell = this$1.colnames[colindex + 1] + rowindex;

          if (sheet[meCell] && sheet[meCell].v) {
            currentConvo.push(Object.assign(
              { sender: 'me', stepTag: 'Cell ' + meCell },
              parseCell(sheet[meCell].v)
            ));
            if (!startcell) { startcell = meCell; }
            emptylines = 0;
          } else if (sheet[botCell] && sheet[botCell].v) {
            currentConvo.push(Object.assign(
              { sender: 'bot', stepTag: 'Cell ' + botCell },
              parseCell(sheet[botCell].v)
            ));
            if (!startcell) { startcell = botCell; }
            emptylines = 0;
          } else {
            if (currentConvo.length > 0) {
              scriptResults.push(new Convo$1(this$1.provider, {
                header: {
                  name: (sheetname + "-" + startcell)
                },
                conversation: currentConvo
              }));
            }
            currentConvo = [];
            startcell = null;
            emptylines++;
          }
          rowindex++;

          if (emptylines > 1) { break }
        }
      }

      if (scriptType === Constants.SCRIPTING_TYPE_UTTERANCES) {
        var currentUtterance = null;
        var emptylines$1 = 0;
        while (true) {
          var nameCell = this$1.colnames[colindex] + rowindex;
          var uttCell = this$1.colnames[colindex + 1] + rowindex;

          if (sheet[nameCell] && sheet[nameCell].v && sheet[uttCell] && sheet[uttCell].v) {
            currentUtterance = new Utterance_1({ name: sheet[nameCell].v, utterances: [ sheet[uttCell].v ] });
            scriptResults.push(currentUtterance);
            emptylines$1 = 0;
          } else if (sheet[uttCell] && sheet[uttCell].v) {
            if (currentUtterance) { currentUtterance.utterances.push(sheet[uttCell].v); }
            emptylines$1 = 0;
          } else {
            currentUtterance = null;
            emptylines$1++;
          }
          rowindex++;

          if (emptylines$1 > 1) { break }
        }
      }
    });

    if (scriptResults && scriptResults.length > 0) {
      if (scriptType === Constants.SCRIPTING_TYPE_CONVO) {
        this.provider.AddConvos(scriptResults);
      } else if (scriptType === Constants.SCRIPTING_TYPE_UTTERANCES) {
        this.provider.AddUtterances(scriptResults);
      }
      return scriptResults
    }
  };

  return CompilerXlsx;
}(CompilerBase_1));

var ConvoHeader$1 = Convo_1.ConvoHeader;
var Convo$2 = Convo_1.Convo;

var CompilerTxt_1 = (function (CompilerBase) {
  function CompilerTxt (provider, caps) {
    if ( caps === void 0 ) caps = {};

    CompilerBase.call(this, provider, caps);

    this.eol = caps[Capabilities.SCRIPTING_TXT_EOL];
  }

  if ( CompilerBase ) CompilerTxt.__proto__ = CompilerBase;
  CompilerTxt.prototype = Object.create( CompilerBase && CompilerBase.prototype );
  CompilerTxt.prototype.constructor = CompilerTxt;

  CompilerTxt.prototype.Validate = function Validate () {
    CompilerBase.prototype.Validate.call(this);
    this._AssertCapabilityExists(Capabilities.SCRIPTING_TXT_EOL);
  };

  CompilerTxt.prototype.GetHeaders = function GetHeaders (scriptBuffer) {
    var scriptData = scriptBuffer;
    if (Buffer.isBuffer(scriptBuffer)) { scriptData = scriptData.toString(); }

    var lines = scriptData.split(this.eol);

    var header = { };

    if (lines && !lines[0].startsWith('#')) {
      header.name = lines[0];
    }
    return new ConvoHeader$1(header)
  };

  CompilerTxt.prototype.Compile = function Compile (scriptBuffer, scriptType) {
    if ( scriptType === void 0 ) scriptType = Constants.SCRIPTING_TYPE_CONVO;

    var scriptData = scriptBuffer;
    if (Buffer.isBuffer(scriptBuffer)) { scriptData = scriptData.toString(); }

    var lines = _.map(scriptData.split(this.eol), function (line) { return line.trim(); });

    if (scriptType === Constants.SCRIPTING_TYPE_CONVO) {
      return this._compileConvo(lines)
    } else if (scriptType === Constants.SCRIPTING_TYPE_UTTERANCES) {
      return this._compileUtterances(lines)
    }
  };

  CompilerTxt.prototype._compileConvo = function _compileConvo (lines) {
    var this$1 = this;

    var convo = {
      header: {},
      conversation: []
    };

    var currentLineIndex = 0;
    var currentLines = [];
    var currentSender = null;
    var currentChannel = null;

    var parseMsg = function (lines) {
      if (!lines) { return null }

      var not = false;
      if (lines[0].startsWith('!')) {
        not = true;
        lines[0] = lines[0].substr(1);
      }
      var content = lines.join(' ');
      if (isJson(content)) {
        return { not: not, sourceData: JSON.parse(content) }
      } else {
        return { not: not, messageText: lines.join(this$1.eol) }
      }
    };

    var pushPrev = function () {
      if (currentSender && currentLines) {
        var convoStep = {
          sender: currentSender,
          channel: currentChannel,
          stepTag: 'Line ' + currentLineIndex
        };
        var ref = parseMsg(currentLines);
        var not = ref.not;
        var messageText = ref.messageText;
        var sourceData = ref.sourceData;
        convoStep.not = not;
        convoStep.messageText = messageText;
        convoStep.sourceData = sourceData;
        convo.conversation.push(convoStep);
      } else if (!currentSender && currentLines) {
        convo.header.name = currentLines[0];
        if (currentLines.length > 1) {
          convo.header.description = currentLines.slice(1).join(this$1.eol);
        }
      }
    };

    lines.forEach(function (line) {
      currentLineIndex++;
      line = line.trim();
      if (!line) ; else if (line.startsWith('#')) {
        pushPrev();

        currentSender = line.substr(1);
        currentChannel = null;
        if (currentSender.indexOf(' ') > 0) {
          currentChannel = currentSender.substr(currentSender.indexOf(' ') + 1).trim();
          currentSender = currentSender.substr(0, currentSender.indexOf(' ')).trim();
        }
        currentLines = [];
      } else {
        currentLines.push(line);
      }
    });
    pushPrev();

    var result = [ new Convo$2(this.provider, convo) ];
    this.provider.AddConvos(result);
    return result
  };

  CompilerTxt.prototype._compileUtterances = function _compileUtterances (lines) {
    if (lines && lines.length > 1) {
      var result = [ new Utterance_1({ name: lines[0], utterances: lines.slice(1) }) ];
      this.provider.AddUtterances(result);
      return result
    }
  };

  CompilerTxt.prototype.Decompile = function Decompile (convos) {
    var this$1 = this;

    if (convos.length > 1) {
      throw new Error('only one convo per script')
    }

    var convo = convos[0];

    var script = '';

    if (convo.header.name) {
      script += convo.header.name + this.eol;
    }
    if (convo.header.description) {
      script += convo.header.description + this.eol;
    }

    convo.conversation.forEach(function (set) {
      if (!set.messageText && !set.sourceData) { return }

      script += this$1.eol;

      script += '#' + set.sender;
      if (set.channel) {
        script += ' ' + set.channel;
      }
      script += this$1.eol;

      if (set.messageText) {
        if (set.not) {
          script += '!';
        }
        script += set.messageText + this$1.eol;
      } else if (set.sourceData) {
        if (set.not) {
          script += '!';
        }
        script += JSON.stringify(set.sourceData, null, 2) + this$1.eol;
      }
    });
    return script
  };

  return CompilerTxt;
}(CompilerBase_1));

var debug$2 = require$$0('botium-ScriptingProvider');



var Convo$3 = Convo_1.Convo;

var globPattern = '**/+(*.convo.txt|*.utterances.txt|*.xlsx)';

var ScriptingProvider_1 = (function () {
  function ScriptingProvider (caps) {
  var this$1 = this;
  if ( caps === void 0 ) caps = {};

    this.caps = caps;
    this.compilers = {};
    this.convos = [];
    this.utterances = { };
    this.match = null;

    this.scriptingEvents = {
      assertBotResponse: function (botresponse, tomatch, stepTag) {
        if (!_.isArray(tomatch)) {
          if (this$1.utterances[tomatch]) {
            tomatch = this$1.utterances[tomatch].utterances;
          } else {
            tomatch = [ tomatch ];
          }
        }
        var found = _.find(tomatch, function (utt) {
          if (_.isString(botresponse)) {
            return this$1.match(botresponse, utt)
          } else {
            return botresponse === utt
          }
        });
        if (!found) {
          throw new Error((stepTag + ": Expected bot response \"" + botresponse + "\" to match one of \"" + tomatch + "\""))
        }
      },
      assertBotNotResponse: function (botresponse, nottomatch, stepTag) {
        try {
          this$1.scriptingEvents.assertBotResponse(botresponse, nottomatch);
          throw new Error((stepTag + ": Expected bot response \"" + botresponse + "\" NOT to match one of \"" + nottomatch + "\""))
        } catch (err) {
        }
      },
      fail: function (msg) {
        throw new Error(msg)
      }
    };
  }

  ScriptingProvider.prototype.Build = function Build () {
    var CompilerXlsx = CompilerXlsx_1;
    this.compilers[Constants.SCRIPTING_FORMAT_XSLX] = new CompilerXlsx(this, this.caps);
    this.compilers[Constants.SCRIPTING_FORMAT_XSLX].Validate();
    var CompilerTxt = CompilerTxt_1;
    this.compilers[Constants.SCRIPTING_FORMAT_TXT] = new CompilerTxt(this, this.caps);
    this.compilers[Constants.SCRIPTING_FORMAT_TXT].Validate();

    debug$2('Using matching mode: ' + this.caps[Capabilities.SCRIPTING_MATCHING_MODE]);
    if (this.caps[Capabilities.SCRIPTING_MATCHING_MODE] === 'regexp') {
      this.match = function (botresponse, utterance) { return (new RegExp(utterance, 'i')).test(botresponse); };
    } else if (this.caps[Capabilities.SCRIPTING_MATCHING_MODE] === 'include') {
      this.match = function (botresponse, utterance) { return botresponse.indexOf(utterance) >= 0; };
    } else if (this.caps[Capabilities.SCRIPTING_MATCHING_MODE] === 'includeLowerCase') {
      this.match = function (botresponse, utterance) { return botresponse.toLowerCase().indexOf(utterance.toLowerCase()) >= 0; };
    } else {
      this.match = function (botresponse, utterance) { return botresponse === utterance; };
    }
  };

  ScriptingProvider.prototype.Compile = function Compile (scriptBuffer, scriptFormat, scriptType) {
    var compiler = this.GetCompiler(scriptFormat);
    return compiler.Compile(scriptBuffer, scriptType)
  };

  ScriptingProvider.prototype.Decompile = function Decompile (convos, scriptFormat) {
    var compiler = this.GetCompiler(scriptFormat);
    return compiler.Decompile(convos)
  };

  ScriptingProvider.prototype.GetCompiler = function GetCompiler (scriptFormat) {
    var result = this.compilers[scriptFormat];
    if (result) { return result }
    throw new Error(("No compiler found for scriptFormat " + scriptFormat))
  };

  ScriptingProvider.prototype.ReadScriptsFromDirectory = function ReadScriptsFromDirectory (convoDir) {
    var this$1 = this;

    var filelist = glob.sync(globPattern, { cwd: convoDir });
    debug$2(("ReadConvosFromDirectory(" + convoDir + ") found filenames: " + filelist));

    filelist.forEach(function (filename) {
      this$1.ReadScript(convoDir, filename);
    });
    debug$2(("ReadConvosFromDirectory(" + convoDir + ") found convos:\n " + (this.convos ? this.convos.join('\n') : 'none')));
    debug$2(("ReadConvosFromDirectory(" + convoDir + ") found utterances:\n " + (this.utterances ? _.map(this.utterances, function (u) { return u; }).join('\n') : 'none')));
  };

  ScriptingProvider.prototype.ReadScript = function ReadScript (convoDir, filename) {
    var fileConvos = [];

    var scriptBuffer = fs.readFileSync(path.resolve(convoDir, filename));

    if (filename.endsWith('.xlsx')) {
      this.Compile(scriptBuffer, Constants.SCRIPTING_FORMAT_XSLX, Constants.SCRIPTING_TYPE_UTTERANCES);
      fileConvos = this.Compile(scriptBuffer, Constants.SCRIPTING_FORMAT_XSLX, Constants.SCRIPTING_TYPE_CONVO);
    } else if (filename.endsWith('.convo.txt')) {
      fileConvos = this.Compile(scriptBuffer, Constants.SCRIPTING_FORMAT_TXT, Constants.SCRIPTING_TYPE_CONVO);
    } else if (filename.endsWith('.utterances.txt')) {
      this.Compile(scriptBuffer, Constants.SCRIPTING_FORMAT_TXT, Constants.SCRIPTING_TYPE_UTTERANCES);
    }
    if (fileConvos) {
      fileConvos.forEach(function (fileConvo) {
        fileConvo.sourceTag = filename;
        if (!fileConvo.header.name) {
          fileConvo.header.name = filename;
        }
      });
    }
  };

  ScriptingProvider.prototype.ExpandConvos = function ExpandConvos () {
    var this$1 = this;

    var expandedConvos = [];
    this.convos.forEach(function (convo) {
      this$1._expandConvo(expandedConvos, convo);
    });
    this.convos = expandedConvos;
    this._sortConvos();
  };

  ScriptingProvider.prototype._expandConvo = function _expandConvo (expandedConvos, currentConvo, convoStepIndex, convoStepsStack) {
    var this$1 = this;
    if ( convoStepIndex === void 0 ) convoStepIndex = 0;
    if ( convoStepsStack === void 0 ) convoStepsStack = [];

    if (convoStepIndex < currentConvo.conversation.length) {
      var currentStep = currentConvo.conversation[convoStepIndex];
      if (currentStep.sender === 'bot') {
        var currentStepsStack = convoStepsStack.slice();
        currentStepsStack.push(Object.assign({}, currentStep));
        this._expandConvo(expandedConvos, currentConvo, convoStepIndex + 1, currentStepsStack);
      } else if (currentStep.sender === 'me') {
        if (currentStep.messageText) {
          var parts = currentStep.messageText.split(' ');
          var uttName = parts[0];
          var uttArgs = parts.slice(1);
          if (this.utterances[uttName]) {
            this.utterances[uttName].utterances.forEach(function (utt) {
              var currentStepsStack = convoStepsStack.slice();
              if (uttArgs) {
                utt = util.format.apply(util, [ utt ].concat( uttArgs ));
              }
              currentStepsStack.push(Object.assign({}, currentStep, { messageText: utt }));
              this$1._expandConvo(expandedConvos, currentConvo, convoStepIndex + 1, currentStepsStack);
            });
            return
          }
        }
        var currentStepsStack$1 = convoStepsStack.slice();
        currentStepsStack$1.push(Object.assign({}, currentStep));
        this._expandConvo(expandedConvos, currentConvo, convoStepIndex + 1, currentStepsStack$1);
      }
    } else {
      expandedConvos.push(new Convo$3(this, Object.assign({}, currentConvo, { conversation: convoStepsStack })));
    }
  };

  ScriptingProvider.prototype._sortConvos = function _sortConvos () {
    this.convos = _.sortBy(this.convos, [function (convo) { return convo.header.name; }]);
    var i = 0;
    this.convos.forEach(function (convo) { convo.header.order = ++i; });
  };

  ScriptingProvider.prototype.AddConvos = function AddConvos (convos) {
    if (convos && _.isArray(convos)) {
      this.convos = _.concat(this.convos, convos);
    } else if (convos) {
      this.convos.push(convos);
    }
    this._sortConvos();
  };

  ScriptingProvider.prototype.AddUtterances = function AddUtterances (utterances) {
    var this$1 = this;

    if (utterances && !_.isArray(utterances)) {
      utterances = [ utterances ];
    }
    if (utterances) {
      _.forEach(utterances, function (utt) {
        var eu = this$1.utterances[utt.name];
        if (eu) {
          eu.utterances = _.uniq(_.concat(eu.utterances, utt.utterances));
        } else {
          this$1.utterances[utt.name] = utt;
        }
      });
    }
  };

  return ScriptingProvider;
}());

var BaseRepo_1 = (function () {
  function BaseRepo (tempDirectory, sources) {
    this.tempDirectory = tempDirectory;
    this.sources = Object.assign({}, sources);
    this.workingDirectory = null;
  }

  BaseRepo.prototype.Validate = function Validate () {
    return Promise.resolve()
  };

  BaseRepo.prototype.Prepare = function Prepare () {
    return Promise.resolve()
  };

  BaseRepo.prototype._AssertSourceExists = function _AssertSourceExists (source) {
    if (!this.sources[source]) {
      throw new Error(("Source property " + source + " not set"))
    }
  };

  return BaseRepo;
}());

var NoRepo_1 = (function (BaseRepo) {
  function NoRepo () {
    BaseRepo.apply(this, arguments);
  }

  if ( BaseRepo ) NoRepo.__proto__ = BaseRepo;
  NoRepo.prototype = Object.create( BaseRepo && BaseRepo.prototype );
  NoRepo.prototype.constructor = NoRepo;

  NoRepo.prototype.Validate = function Validate () {
    return BaseRepo.prototype.Validate.call(this)
  };

  NoRepo.prototype.Prepare = function Prepare () {
    return BaseRepo.prototype.Prepare.call(this)
  };

  return NoRepo;
}(BaseRepo_1));

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var ProcessUtils = createCommonjsModule(function (module) {
var debug = require$$0('botium-ProcessUtils');

module.exports = {
  childCommandLineRun: function (cmd, ignoreErrors, processOptions) {
    if ( ignoreErrors === void 0 ) ignoreErrors = false;
    if ( processOptions === void 0 ) processOptions = {};

    var cmdOptions = cmd.split(' ');
    var cmdPart = cmdOptions[0];
    cmdOptions.splice(0, 1);
    return module.exports.childProcessRun(cmdPart, cmdOptions, ignoreErrors, processOptions)
  },

  childProcessRun: function (cmd, cmdOptions, ignoreErrors, processOptions) {
    if ( ignoreErrors === void 0 ) ignoreErrors = false;
    if ( processOptions === void 0 ) processOptions = {};

    return new Promise(function (resolve, reject) {
      debug('Running Command: ' + cmd + ' ' + _.join(cmdOptions, ' '));

      var runningProcess = child_process.spawn(cmd, cmdOptions, processOptions);

      var stdout = [];
      var stderr = [];

      runningProcess.stdout.on('data', function (data) {
        if (data) {
          debug((cmd + " STDOUT: " + data));
          stdout.push(data);
        }
      });
      runningProcess.stderr.on('data', function (data) {
        if (data) {
          debug((cmd + " STDERR: " + data));
          stderr.push(data);
        }
      });
      runningProcess.on('close', function (code) {
        debug(cmd + ' exited with code ' + code);
        if (code === 0 || ignoreErrors) {
          resolve({ stdout: stdout, stderr: stderr });
        } else {
          reject(new Error((cmd + " returned error code " + code)));
        }
      });
      runningProcess.on('error', function (err) {
        if (ignoreErrors) {
          resolve();
        } else {
          reject(new Error((cmd + " failed: " + (util.inspect(err)))));
        }
      });
    })
  }
};
});
var ProcessUtils_1 = ProcessUtils.childCommandLineRun;
var ProcessUtils_2 = ProcessUtils.childProcessRun;

var debug$3 = require$$0('botium-GitRepo');





var GitRepo_1 = (function (BaseRepo) {
  function GitRepo () {
    BaseRepo.apply(this, arguments);
  }

  if ( BaseRepo ) GitRepo.__proto__ = BaseRepo;
  GitRepo.prototype = Object.create( BaseRepo && BaseRepo.prototype );
  GitRepo.prototype.constructor = GitRepo;

  GitRepo.prototype.Validate = function Validate () {
    var this$1 = this;

    return BaseRepo.prototype.Validate.call(this).then(function () {
      this$1._AssertSourceExists(Source.GITPATH);
      this$1._AssertSourceExists(Source.GITURL);
      this$1._AssertSourceExists(Source.GITBRANCH);
      this$1._AssertSourceExists(Source.GITDIR);
    })
  };

  GitRepo.prototype.Prepare = function Prepare () {
    var this$1 = this;

    return new Promise(function (resolve, reject) {
      async.series([

        function (cloneDirectoryCreated) {
          this$1.workingDirectory = path.resolve(this$1.tempDirectory, 'git');

          mkdirp(this$1.workingDirectory, function (err) {
            if (err) {
              return cloneDirectoryCreated(new Error(("Unable to create clone directory " + (this$1.workingDirectory) + ": " + err)))
            }
            cloneDirectoryCreated();
          });
        },

        function (cloneReady) {
          var gitCmdOptions = [
            'clone',
            '-b',
            this$1.sources[Source.GITBRANCH],
            '--single-branch',
            '--depth',
            '1',
            this$1.sources[Source.GITURL],
            this$1.workingDirectory
          ];
          ProcessUtils.childProcessRun(this$1.sources[Source.GITPATH], gitCmdOptions, false, { cwd: this$1.workingDirectory })
            .then(function () { return cloneReady(); })
            .catch(cloneReady);
        },

        function (workingDirectoryChanged) {
          this$1.workingDirectory = path.resolve(this$1.workingDirectory, this$1.sources[Source.GITDIR]);
          workingDirectoryChanged();
        },

        function (prepareReady) {
          if (this$1.sources[Source.GITPREPARECMD]) {
            ProcessUtils.childCommandLineRun(this$1.sources[Source.GITPREPARECMD], false, { cwd: this$1.workingDirectory })
              .then(function () { return prepareReady(); })
              .catch(prepareReady);
          } else {
            prepareReady();
          }
        }

      ], function (err) {
        if (err) {
          return reject(err)
        }
        debug$3(("git checkout out to " + (this$1.workingDirectory)));
        resolve();
      });
    })
  };

  return GitRepo;
}(BaseRepo_1));

var LocalRepo_1 = (function (BaseRepo) {
  function LocalRepo () {
    BaseRepo.apply(this, arguments);
  }

  if ( BaseRepo ) LocalRepo.__proto__ = BaseRepo;
  LocalRepo.prototype = Object.create( BaseRepo && BaseRepo.prototype );
  LocalRepo.prototype.constructor = LocalRepo;

  LocalRepo.prototype.Validate = function Validate () {
    var this$1 = this;

    return BaseRepo.prototype.Validate.call(this).then(function () {
      this$1._AssertSourceExists(Source.LOCALPATH);

      var checkPath = this$1.sources[Source.LOCALPATH];
      fs.stat(checkPath, function (err, stats) {
        if (err) {
          throw new Error((checkPath + " not available: " + err))
        }
        if (stats.isDirectory() && !stats.isSymbolicLink()) {
          fs.access(checkPath, fs.constants.W_OK, function (err1) {
            if (err) {
              throw new Error((checkPath + " not writeable: " + err))
            }
          });
        } else {
          throw new Error((checkPath + " not a regular directory"))
        }
      });
    })
  };

  LocalRepo.prototype.Prepare = function Prepare () {
    // No need to prepare anything
    this.workingDirectory = path.resolve(this.sources[Source.LOCALPATH]);
    return Promise.resolve()
  };

  return LocalRepo;
}(BaseRepo_1));

var Commands = {
  BUILD_CONTAINER: 'BUILD_CONTAINER',
  START_CONTAINER: 'START_CONTAINER',
  SENDTOBOT: 'SENDTOBOT',
  STOP_CONTAINER: 'STOP_CONTAINER',
  CLEAN_CONTAINER: 'CLEAN_CONTAINER'
};

var QueueTimeoutError_1 = (function (Error) {
  function QueueTimeoutError (timeoutMillis) {
    Error.call(this, ("Queue.pop timeout after " + timeoutMillis));
  }

  if ( Error ) QueueTimeoutError.__proto__ = Error;
  QueueTimeoutError.prototype = Object.create( Error && Error.prototype );
  QueueTimeoutError.prototype.constructor = QueueTimeoutError;

  return QueueTimeoutError;
}(Error));

var Queue_1 = (function () {
  function Queue () {
    this.queue = [];
    this.listeners = [];
    this.pushListener = null;
  }

  Queue.prototype.clear = function clear () {
    this.queue = [];
    this.listeners = [];
  };

  Queue.prototype.push = function push (msg) {
    if (this.pushListener) {
      this.pushListener(msg);
    }

    if (this.listeners.length > 0) {
      this.listeners.shift()(msg);
    } else {
      this.queue.push(msg);
    }
  };

  Queue.prototype.pop = function pop (timeoutMillis) {
    var this$1 = this;

    if (this.queue.length > 0) {
      return Promise.resolve(this.queue.shift())
    }
    return new Promise(function (resolve, reject) {
      var listener = null;
      var timeoutRequest = async.timeout(function (timeoutCallback) {
        listener = function (msg) {
          timeoutCallback(null, msg);
        };
        this$1.listeners.push(listener);
      }, timeoutMillis);

      timeoutRequest(function (err, msg) {
        if (err && err.code === 'ETIMEDOUT') {
          this$1.listeners.splice(this$1.listeners.indexOf(listener), 1);
          reject(new QueueTimeoutError_1(timeoutMillis));
        } else if (err) {
          this$1.listeners.splice(this$1.listeners.indexOf(listener), 1);
          reject(new Error(("Queue pop error " + (util.inspect(err)))));
        } else {
          resolve(msg);
        }
      });
    })
  };

  Queue.prototype.registerPushListener = function registerPushListener (callback) {
    this.pushListener = callback;
  };

  return Queue;
}());

var debug$4 = require$$0('botium-BaseContainer');






var BaseContainer_1 = (function () {
  function BaseContainer (eventEmitter, tempDirectory, repo, caps, envs) {
    this.eventEmitter = eventEmitter;
    this.repo = repo;
    this.caps = Object.assign({}, caps);
    this.envs = Object.assign({}, envs);
    this.tempDirectory = tempDirectory;
    this.cleanupTasks = [];
    this.queues = {};
  }

  BaseContainer.prototype.Validate = function Validate () {
    return Promise.resolve()
  };

  BaseContainer.prototype.Build = function Build () {
    return Promise.resolve(this)
  };

  BaseContainer.prototype.Start = function Start () {
    this.queues = {};
    return Promise.resolve(this)
  };

  BaseContainer.prototype.UserSaysText = function UserSaysText (text) {
    var mockMsg = new BotiumMockMessage_1({ sender: 'me', messageText: text });
    return this.UserSays(mockMsg)
  };

  BaseContainer.prototype.UserSays = function UserSays (msgMock) {
    return Promise.resolve(this)
  };

  BaseContainer.prototype.WaitBotSays = function WaitBotSays (channel, timeoutMillis) {
    var this$1 = this;
    if ( channel === void 0 ) channel = null;
    if ( timeoutMillis === void 0 ) timeoutMillis = null;

    if (!channel) { channel = 'default'; }
    if (!timeoutMillis) { timeoutMillis = this.caps[Capabilities.WAITFORBOTTIMEOUT]; }

    if (!this.queues[channel]) {
      this.queues[channel] = new Queue_1();
    }

    return new Promise(function (resolve, reject) {
      this$1.queues[channel].pop(timeoutMillis)
        .then(function (botMsg) {
          resolve(botMsg);
        })
        .catch(function (err) {
          debug$4(("WaitBotSays error " + (util.inspect(err))));
          resolve();
        });
    })
  };

  BaseContainer.prototype.WaitBotSaysText = function WaitBotSaysText (channel, timeoutMillis) {
    var this$1 = this;
    if ( channel === void 0 ) channel = null;
    if ( timeoutMillis === void 0 ) timeoutMillis = null;

    return new Promise(function (resolve, reject) {
      this$1.WaitBotSays(channel, timeoutMillis)
        .then(function (botMsg) {
          if (botMsg) {
            resolve(botMsg.messageText);
          } else {
            resolve();
          }
        })
        .catch(function (err) {
          debug$4(("WaitBotSaysText error " + (util.inspect(err))));
          resolve();
        });
    })
  };

  BaseContainer.prototype.Restart = function Restart () {
    var this$1 = this;

    return new Promise(function (resolve, reject) {
      this$1.Stop()
        .then(function () { return this$1.Start(); })
        .then(function () { return resolve(); })
        .catch(function (err) { return reject(err); });
    })
  };

  BaseContainer.prototype.Stop = function Stop () {
    return Promise.resolve(this)
  };

  BaseContainer.prototype.Clean = function Clean () {
    var this$1 = this;

    return new Promise(function (resolve, reject) {
      async.series([

        function (rimraffed) {
          if (this$1.caps[Capabilities.CLEANUPTEMPDIR]) {
            rimraf(this$1.tempDirectory, function (err) {
              if (err) { debug$4(("Cleanup temp dir " + (this$1.tempDirectory) + " failed: " + (util.inspect(err)))); }
              rimraffed();
            });
          } else {
            rimraffed();
          }
        },

        function (cleanupTasksDone) {
          if (this$1.cleanupTasks) {
            async.series(
              this$1.cleanupTasks.map(function (task) {
                return function (cb) {
                  task(function (err) {
                    if (err) { debug$4(("Cleanup failed: " + (util.inspect(err)))); }
                    cb();
                  });
                }
              }),
              function () {
                cleanupTasksDone();
              }
            );
          } else {
            cleanupTasksDone();
          }
        }

      ], function (err) {
        if (err) {
          return reject(new Error(("Cleanup failed " + (util.inspect(err)))))
        }
        resolve();
      });
    })
  };

  BaseContainer.prototype._AssertCapabilityExists = function _AssertCapabilityExists (cap) {
    if (!this.caps[cap]) {
      throw new Error(("Capability property " + cap + " not set"))
    }
  };

  BaseContainer.prototype._AssertOneCapabilityExists = function _AssertOneCapabilityExists () {
    var this$1 = this;
    var i = arguments.length, argsArray = Array(i);
    while ( i-- ) argsArray[i] = arguments[i];

    var checkCaps = [].concat( argsArray );
    var found = checkCaps.find(function (cap) { return this$1.caps[cap]; });
    if (!found) {
      throw new Error(("Capability property of " + (checkCaps.join()) + " not set"))
    }
  };

  BaseContainer.prototype._QueueBotSays = function _QueueBotSays (botMsg) {
    if (!botMsg.channel) { botMsg.channel = 'default'; }
    if (!botMsg.sender) { botMsg.sender = 'bot'; }

    if (!this.queues[botMsg.channel]) {
      this.queues[botMsg.channel] = new Queue_1();
    }

    this.queues[botMsg.channel].push(botMsg);
    this.eventEmitter.emit(Events.MESSAGE_RECEIVEDFROMBOT, this, botMsg);
  };

  return BaseContainer;
}());

var debug$5 = require$$0('botium-GridContainer');







var GridContainer_1 = (function (BaseContainer) {
  function GridContainer () {
    BaseContainer.apply(this, arguments);
  }

  if ( BaseContainer ) GridContainer.__proto__ = BaseContainer;
  GridContainer.prototype = Object.create( BaseContainer && BaseContainer.prototype );
  GridContainer.prototype.constructor = GridContainer;

  GridContainer.prototype.Validate = function Validate () {
    var this$1 = this;

    return BaseContainer.prototype.Validate.call(this).then(function () {
      this$1._AssertCapabilityExists(Capabilities.BOTIUMGRIDURL);
    })
  };

  GridContainer.prototype.Build = function Build () {
    var this$1 = this;

    this.buildPromise = this._defer();

    async.series([
      function (baseComplete) {
        BaseContainer.prototype.Build.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
      },

      function (socketComplete) {
        this$1.socket = socket(this$1.caps[Capabilities.BOTIUMGRIDURL]);

        this$1.socket.on('connect', function () {
          debug$5('connected');
          this$1.socket.emit('authentication', { apiToken: this$1.caps[Capabilities.BOTIUMAPITOKEN] });
        });
        this$1.socket.on('connect_error', function (err) {
          debug$5(("connect_error " + (util.inspect(err))));
        });
        this$1.socket.on('connect_timeout', function (timeout) {
          debug$5(("connect_timeout " + (util.inspect(timeout))));
        });
        this$1.socket.on('error', function (err) {
          debug$5(("error " + (util.inspect(err))));
        });
        this$1.socket.on('authenticated', function () {
          debug$5('authenticated');
          this$1.socket.emit(Commands.BUILD_CONTAINER, this$1.caps, this$1.repo.sources, this$1.envs);
        });
        this$1.socket.on('unauthorized', function (err) {
          debug$5(("unauthorized " + (util.inspect(err))));
          socketComplete(("Grid Access not authorized: " + (util.inspect(err))));
        });
        this$1.socket.on(Events.TOOMUCHWORKERS_ERROR, function (err) {
          debug$5(("TOOMUCHWORKERS_ERROR " + (util.inspect(err))));
          socketComplete(("Grid Access not possible: " + (util.inspect(err))));
        });
        this$1.socket.on(Events.CONTAINER_BUILT, function () {
          debug$5(Events.CONTAINER_BUILT);
          socketComplete();
        });
        this$1.socket.on(Events.CONTAINER_BUILD_ERROR, function (err) {
          debug$5(("CONTAINER_BUILD_ERROR " + (util.inspect(err))));
          socketComplete(("Grid Build failed: " + (util.inspect(err))));
        });

        this$1.socket.on(Events.CONTAINER_STARTED, function () {
          debug$5(Events.CONTAINER_STARTED);
          this$1.eventEmitter.emit(Events.CONTAINER_STARTED, this$1);
          if (this$1.startPromise) {
            this$1.startPromise.resolve(this$1);
            this$1.startPromise = null;
          }
        });
        this$1.socket.on(Events.CONTAINER_START_ERROR, function (err) {
          debug$5(("CONTAINER_START_ERROR " + (util.inspect(err))));
          this$1.eventEmitter.emit(Events.CONTAINER_START_ERROR, this$1, err);
          if (this$1.startPromise) {
            this$1.startPromise.reject(("Grid Start failed: " + (util.inspect(err))));
            this$1.startPromise = null;
          }
        });

        this$1.socket.on(Events.MESSAGE_RECEIVEDFROMBOT, function (botMsg) {
          debug$5(("MESSAGE_RECEIVEDFROMBOT " + (util.inspect(botMsg))));
          this$1._QueueBotSays(new BotiumMockMessage_1(botMsg));
        });

        this$1.socket.on(Events.CONTAINER_STOPPED, function () {
          debug$5(Events.CONTAINER_STOPPED);
          this$1.eventEmitter.emit(Events.CONTAINER_STOPPED, this$1);
          if (this$1.stopPromise) {
            this$1.stopPromise.resolve(this$1);
            this$1.stopPromise = null;
          }
        });
        this$1.socket.on(Events.CONTAINER_STOP_ERROR, function (err) {
          debug$5(("CONTAINER_STOP_ERROR " + (util.inspect(err))));
          this$1.eventEmitter.emit(Events.CONTAINER_STOP_ERROR, this$1, err);
          if (this$1.stopPromise) {
            this$1.stopPromise.reject(("Grid Stop failed: " + (util.inspect(err))));
            this$1.stopPromise = null;
          }
        });

        this$1.socket.on(Events.CONTAINER_CLEANED, function () {
          debug$5(Events.CONTAINER_CLEANED);
          this$1.eventEmitter.emit(Events.CONTAINER_CLEANED, this$1);
          if (this$1.cleanPromise) {
            this$1.cleanPromise.resolve(this$1);
            this$1.cleanPromise = null;
          }
          this$1.socket.disconnect();
          this$1.socket = null;
        });
        this$1.socket.on(Events.CONTAINER_CLEAN_ERROR, function (err) {
          debug$5(("CONTAINER_CLEAN_ERROR " + (JSON.stringify(err))));
          this$1.eventEmitter.emit(Events.CONTAINER_CLEAN_ERROR, this$1, err);
          if (this$1.cleanPromise) {
            this$1.cleanPromise.reject(("Grid Clean failed: " + (util.inspect(err))));
            this$1.cleanPromise = null;
          }
          this$1.socket.disconnect();
          this$1.socket = null;
        });
      }
    ], function (err) {
      if (err) {
        this$1.buildPromise.reject(new Error(("Cannot build docker containers: " + (util.inspect(err)))));
      } else {
        this$1.buildPromise.resolve(this$1);
      }
      this$1.buildPromise = null;
    });
    return this.buildPromise.promise
  };

  GridContainer.prototype.Start = function Start () {
    var this$1 = this;

    this.eventEmitter.emit(Events.CONTAINER_STARTING, this);

    return BaseContainer.prototype.Start.call(this).then(function () {
      if (this$1.startPromise) { return Promise.reject(new Error('already starting')) }
      if (this$1.socket) {
        this$1.startPromise = this$1._defer();
        this$1.socket.emit(Commands.START_CONTAINER);

        return this$1.startPromise.promise
      } else {
        this$1.eventEmitter.emit(Events.CONTAINER_START_ERROR, this$1, 'Remote Agent not online');
        return Promise.reject(new Error('Remote Agent not online'))
      }
    })
  };

  GridContainer.prototype.UserSays = function UserSays (mockMsg) {
    var this$1 = this;

    return new Promise(function (resolve, reject) {
      if (this$1.socket) {
        this$1.socket.emit(Commands.SENDTOBOT, mockMsg);
        this$1.eventEmitter.emit(Events.MESSAGE_SENTTOBOT, this$1, mockMsg);
        resolve(this$1);
      } else {
        this$1.eventEmitter.emit(Events.MESSAGE_SENDTOBOT_ERROR, this$1, 'Remote Agent not online');
        reject(new Error('Remote Agent not online'));
      }
    })
  };

  GridContainer.prototype.Stop = function Stop () {
    var this$1 = this;

    this.eventEmitter.emit(Events.CONTAINER_STOPPING, this);

    return BaseContainer.prototype.Stop.call(this).then(function () {
      if (this$1.stopPromise) { return Promise.reject(new Error('already stopping')) }
      if (this$1.socket) {
        this$1.stopPromise = this$1._defer();
        this$1.socket.emit(Commands.STOP_CONTAINER);

        return this$1.stopPromise.promise
      } else {
        return Promise.resolve(this$1)
      }
    })
  };

  GridContainer.prototype.Clean = function Clean () {
    var this$1 = this;

    this.eventEmitter.emit(Events.CONTAINER_CLEANING, this);

    return BaseContainer.prototype.Clean.call(this).then(function () {
      if (this$1.cleanPromise) { return Promise.reject(new Error('already cleaning')) }
      if (this$1.socket) {
        this$1.cleanPromise = this$1._defer();
        this$1.socket.emit(Commands.CLEAN_CONTAINER);

        return this$1.cleanPromise.promise
      } else {
        return Promise.resolve(this$1)
      }
    })
  };

  GridContainer.prototype._defer = function _defer () {
    var deferred = {
      promise: null,
      resolve: null,
      reject: null
    };
    deferred.promise = new Promise(function (resolve, reject) {
      deferred.resolve = resolve;
      deferred.reject = reject;
    });
    return deferred
  };

  return GridContainer;
}(BaseContainer_1));

var DockerCmd_1 = (function () {
  function DockerCmd (ref) {
  var projectname = ref.projectname;
  var dockercomposepath = ref.dockercomposepath;
  var uniquecontainernames = ref.uniquecontainernames;
  var composefiles = ref.composefiles;

    this.projectname = projectname;
    this.dockercomposepath = dockercomposepath;
    this.composefiles = composefiles;
    if (uniquecontainernames) {
      this.containername = slug(((this.projectname) + " " + (randomatic('Aa0', 5))));
    } else {
      this.containername = slug(("" + (this.projectname)));
    }
  }

  DockerCmd.prototype.setupContainer = function setupContainer () {
    var _this = this;
    return new Promise(function (resolve, reject) {
      async.series([
        function (stopDone) {
          _this.stopContainer(true).then(function () { return stopDone(); }).catch(function () { return stopDone(); });
        },
        function (teardownDone) {
          _this.teardownContainer(true).then(function () { return teardownDone(); }).catch(function () { return teardownDone(); });
        },
        function (buildContainerDone) {
          var cmdOptions = _this._dockerComposeCmdOptions();
          cmdOptions.push('build');

          _this._dockerComposeRun(cmdOptions, false).then(function () { return buildContainerDone(); }).catch(buildContainerDone);
        }
      ],
      function (err) {
        if (err) { return reject(err) }
        resolve();
      });
    })
  };

  DockerCmd.prototype.teardownContainer = function teardownContainer (ignoreErrors) {
    var cmdOptions = this._dockerComposeCmdOptions();
    cmdOptions.push('down');

    return this._dockerComposeRun(cmdOptions, ignoreErrors)
  };

  DockerCmd.prototype.startContainer = function startContainer () {
    var cmdOptions = this._dockerComposeCmdOptions();
    cmdOptions.push('up');
    cmdOptions.push('-d');

    return this._dockerComposeRun(cmdOptions, false)
  };

  DockerCmd.prototype.stopContainer = function stopContainer (ignoreErrors) {
    var cmdOptions = this._dockerComposeCmdOptions();
    cmdOptions.push('kill');

    return this._dockerComposeRun(cmdOptions, ignoreErrors)
  };

  // Private Functions

  DockerCmd.prototype._dockerComposeCmdOptions = function _dockerComposeCmdOptions () {
    var cmdOptions = [];
    cmdOptions.push('-p');
    cmdOptions.push(this.containername);
    if (process.env.DEBUG && process.env.DEBUG.indexOf('DockerCmdVerbose') >= 0) {
      cmdOptions.push('--verbose');
    }

    _.forEach(this.composefiles, function (composefile) {
      cmdOptions.push('-f');
      cmdOptions.push(composefile);
    });
    return cmdOptions
  };

  DockerCmd.prototype._dockerComposeRun = function _dockerComposeRun (cmdOptions, ignoreErrors) {
    return ProcessUtils.childProcessRun(this.dockercomposepath, cmdOptions, ignoreErrors)
  };

  return DockerCmd;
}());

var debug$6 = require$$0('botium-TcpPortUtils');

var TcpPortUtils = {
  WaitForPort: function (hostname, portToCheck) {
    return new Promise(function (resolve, reject) {
      var online = false;
      async.until(
        function () { return online; },
        function (callback) {
          debug$6(("WaitForPort checking port usage " + hostname + ":" + portToCheck + " before proceed"));

          tcpPortUsed.check(portToCheck, hostname)
            .then(function (inUse) {
              debug$6(("WaitForPort port usage (" + hostname + ":" + portToCheck + "): " + inUse));
              if (inUse) {
                online = true;
                callback();
              } else {
                setTimeout(callback, 2000);
              }
            }, function (err) {
              debug$6(("WaitForPort error on port check " + hostname + ":" + portToCheck + ": " + err));
              setTimeout(callback, 2000);
            });
        },
        function (err) {
          if (err) { return reject(err) }
          resolve();
        });
    })
  },

  GetFreePortInRange: function (hostname, portRange) {
    return new Promise(function (resolve, reject) {
      var rangeExpression = /^([0-9]+)-([0-9]+)$/;
      var rangeMatch = portRange.match(rangeExpression);
      if (!rangeMatch || rangeMatch.length !== 3) {
        return reject(new Error(("GetFreePortInRange Not a port range expression \"" + portRange + "\", expected portFrom-portTo")))
      }
      var found = false;
      var portToCheck = parseInt(rangeMatch[1]);
      var portToCheckMax = parseInt(rangeMatch[2]);
      async.until(
        function () { return found || portToCheck > portToCheckMax; },
        function (callback) {
          debug$6(("GetFreePortInRange checking port usage " + hostname + ":" + portToCheck + " before proceed"));

          tcpPortUsed.check(portToCheck, hostname)
            .then(function (inUse) {
              debug$6(("GetFreePortInRange port usage (" + hostname + ":" + portToCheck + "): " + inUse));
              if (inUse) {
                portToCheck++;
                callback();
              } else {
                found = true;
                callback();
              }
            }, function (err) {
              debug$6(("GetFreePortInRange error on port check " + hostname + ":" + portToCheck + ": " + err));
              portToCheck++;
              callback();
            });
        },
        function (err) {
          if (err) { return reject(err) }
          if (!found) { return reject(new Error(("GetFreePortInRange no free port found in range " + portRange))) }
          resolve(portToCheck);
        });
    })
  }
};

var SafeFileCopy = function (src, dest) {
  return new Promise(function (resolve, reject) {
    fs.readFile(src, function (err, data) {
      if (err) { return reject(new Error(("read file " + src + " failed: " + err))) }
      fs.writeFile(dest, data, function (err) {
        if (err) { return reject(new Error(("write file " + dest + " failed: " + err))) }
        resolve();
      });
    });
  })
};

var BotiumMockCommand = {
  MOCKCMD_SENDTOBOT: 'MOCKCMD_SENDTOBOT',
  MOCKCMD_RECEIVEDFROMBOT: 'MOCKCMD_RECEIVEDFROMBOT'
};

var debug$7 = require$$0('botium-DockerMocks');









var botiumPackageRootDir = findRoot();

var BaseMock = function BaseMock () {
  this.publishPort = null;
  this.publishIp = null;
  this.capNamePublishPort = null;
  this.capNamePublishPortRange = null;
  this.mockDir = null;
  this.packageDir = null;
  this.initCommand = null;
  this.dockerFile = null;
  this.dockerComposeFile = null;
};

BaseMock.prototype.SelectPublishPort = function SelectPublishPort (publishIp, caps) {
    var this$1 = this;

  this.publishIp = publishIp;
  if (caps[this.capNamePublishPort]) {
    this.publishPort = caps[this.capNamePublishPort];
    if (caps[Capabilities.BOTIUMGRIDSLOT]) {
      this.publishPort += caps[Capabilities.BOTIUMGRIDSLOT];
    }
    return Promise.resolve()
  } else {
    return new Promise(function (resolve, reject) {
      TcpPortUtils.GetFreePortInRange(this$1.publishIp, caps[this$1.capNamePublishPortRange])
        .then(function (port) {
          this$1.publishPort = port;
          resolve();
        })
        .catch(reject);
    })
  }
};

BaseMock.prototype.PrepareDocker = function PrepareDocker (mockDir) {
    var this$1 = this;

  this.mockDir = mockDir;
  return new Promise(function (resolve, reject) {
    async.series([
      function (packageCopied) {
        copyDir(path.resolve(botiumPackageRootDir, this$1.packageDir), this$1.mockDir, function (err) {
          if (err) { return packageCopied(("Error copying mock to " + (this$1.mockDir) + ": " + (util.inspect(err)))) }
          if (this$1.initCommand) {
            ProcessUtils.childCommandLineRun(this$1.initCommand, false, { cwd: this$1.mockDir })
              .then(function () { return packageCopied(); })
              .catch(packageCopied);
          } else {
            packageCopied();
          }
        });
      },

      function (dockerfileCopied) {
        var dockermockOverride = path.resolve(process.cwd(), this$1.dockerFile);
        fs.stat(dockermockOverride, function (err, stats) {
          if (!err && stats.isFile()) {
            debug$7(("Docker file " + dockermockOverride + " present, using it."));

            SafeFileCopy(dockermockOverride, path.resolve(this$1.mockDir, this$1.dockerFile))
              .then(function () { return dockerfileCopied(); })
              .catch(function (err) { return dockerfileCopied(("Copying Docker file " + dockermockOverride + " failed " + (util.inspect(err)))); });
          } else {
            dockerfileCopied();
          }
        });
      }
    ], function (err) {
      if (err) {
        return reject(new Error(("PrepareDocker failed " + (util.inspect(err)))))
      }
      resolve();
    });
  })
};

BaseMock.prototype.GetDockerCompose = function GetDockerCompose () {
    var this$1 = this;

  return new Promise(function (resolve) {
    var dockermockOverride = path.resolve(process.cwd(), this$1.dockerComposeFile);
    fs.stat(dockermockOverride, function (err, stats) {
      if (!err && stats.isFile()) {
        debug$7(("Docker file " + dockermockOverride + " present, using it."));
        resolve(dockermockOverride);
      } else {
        resolve(path.resolve(this$1.mockDir, this$1.dockerComposeFile));
      }
    });
  })
};

BaseMock.prototype.Start = function Start (container) {
    var this$1 = this;

  return new Promise(function (resolve, reject) {
    async.series([

      function (mockupOnline) {
        TcpPortUtils.WaitForPort(this$1.publishIp, this$1.publishPort)
          .then(function () { return mockupOnline(); })
          .catch(mockupOnline);
      },

      function (endpointOnline) {
        this$1.mockUrl = "http://" + (this$1.publishIp) + ":" + (this$1.publishPort);
        var online = false;
        async.until(
          function () { return online; },
          function (callback) {
            var options = {
              uri: this$1.mockUrl,
              method: 'GET'
            };
            this$1.debug(("Mock - checking endpoint " + (this$1.mockUrl) + " before proceed"));
            request(options, function (err, response, body) {
              if (err) {
                setTimeout(callback, 2000);
              } else if (response && response.statusCode === 200) {
                this$1.debug(("Mock - endpoint " + (this$1.mockUrl) + " is online"));
                online = true;
                callback();
              } else {
                setTimeout(callback, 2000);
              }
            });
          },
          endpointOnline
        );
      },

      function (socketStartDone) {
        if (this$1.socket) {
          this$1.socket.disconnect();
          this$1.socket = null;
        }

        this$1.socket = socket.connect(this$1.mockUrl);
        this$1.socket.on(BotiumMockCommand.MOCKCMD_RECEIVEDFROMBOT, function (botMsg) {
          this$1.debug(("Mock - socket received from bot " + (util.inspect(botMsg))));
          container._QueueBotSays(new BotiumMockMessage_1(botMsg));
        });
        this$1.socket.on('error', function (err) {
          this$1.debug(("Mock - socket connection error! " + (util.inspect(err))));
        });
        this$1.socket.on('connect', function () {
          this$1.debug(("Mock - socket connected " + (this$1.mockUrl)));
          container.eventEmitter.emit(Events.BOT_CONNECTED, this$1, this$1.socket);
          socketStartDone();
        });
      }

    ], function (err) {
      if (err) {
        return reject(new Error(("Start failed " + (util.inspect(err)))))
      }
      resolve();
    });
  })
};

BaseMock.prototype.Stop = function Stop () {
    var this$1 = this;

  return new Promise(function (resolve) {
    if (this$1.socket) {
      this$1.socket.disconnect();
      this$1.socket = null;
      this$1.debug('Socket disconnected');
    }
    resolve();
  })
};

var DockerMocks = {
  Facebook: (function (BaseMock) {
  function FacebookMock () {
      BaseMock.call(this);
      this.capNamePublishPort = Capabilities.FACEBOOK_PUBLISHPORT;
      this.capNamePublishPortRange = Capabilities.FACEBOOK_PUBLISHPORT_RANGE;
      this.packageDir = 'src/mocks/facebook';
      this.dockerFile = 'Dockerfile.fbmock';
      this.dockerComposeFile = 'docker-compose.fbmock.yml';
      this.debug = require$$0('botium-FacebookMock');
    }

  if ( BaseMock ) FacebookMock.__proto__ = BaseMock;
  FacebookMock.prototype = Object.create( BaseMock && BaseMock.prototype );
  FacebookMock.prototype.constructor = FacebookMock;

    FacebookMock.prototype.FillDockerEnv = function FillDockerEnv (composeEnv, caps, logging) {
      composeEnv.services['botium-fbmock'] = {
        build: {
          context: this.mockDir
        },
        logging: _.cloneDeep(logging),
        volumes: [
          ((this.mockDir) + ":/usr/src/app")
        ],
        ports: [
          ((this.publishPort) + ":" + (this.publishPort))
        ],
        environment: {
          BOTIUM_FACEBOOK_WEBHOOKPORT: caps[Capabilities.FACEBOOK_WEBHOOK_PORT],
          BOTIUM_FACEBOOK_WEBHOOKPATH: caps[Capabilities.FACEBOOK_WEBHOOK_PATH],
          BOTIUM_FACEBOOK_PUBLISHPORT: this.publishPort,
          BOTIUM_FACEBOOK_SENDDELIVERY: ("" + (caps[Capabilities.FACEBOOK_SEND_DELIVERY_CONFIRMATION]))
        }
      };
    };

  return FacebookMock;
}(BaseMock)),
  Slack: (function (BaseMock) {
  function SlackMock () {
      BaseMock.call(this);
      this.capNamePublishPort = Capabilities.SLACK_PUBLISHPORT;
      this.capNamePublishPortRange = Capabilities.SLACK_PUBLISHPORT_RANGE;
      this.packageDir = 'src/mocks/slack';
      this.dockerFile = 'Dockerfile.slackmock';
      this.dockerComposeFile = 'docker-compose.slackmock.yml';
      this.debug = require$$0('botium-SlackMock');
    }

  if ( BaseMock ) SlackMock.__proto__ = BaseMock;
  SlackMock.prototype = Object.create( BaseMock && BaseMock.prototype );
  SlackMock.prototype.constructor = SlackMock;

    SlackMock.prototype.FillDockerEnv = function FillDockerEnv (composeEnv, caps, logging) {
      composeEnv.services['botium-slackmock'] = {
        build: {
          context: this.mockDir
        },
        logging: _.cloneDeep(logging),
        volumes: [
          ((this.mockDir) + ":/usr/src/app")
        ],
        ports: [
          ((this.publishPort) + ":" + (this.publishPort))
        ],
        environment: {
          BOTIUM_SLACK_EVENTPORT: caps[Capabilities.SLACK_EVENT_PORT],
          BOTIUM_SLACK_EVENTPATH: caps[Capabilities.SLACK_EVENT_PATH],
          BOTIUM_SLACK_OAUTHPORT: caps[Capabilities.SLACK_OAUTH_PORT],
          BOTIUM_SLACK_OAUTHPATH: caps[Capabilities.SLACK_OAUTH_PATH],
          BOTIUM_SLACK_PUBLISHPORT: this.publishPort
        }
      };
    };

  return SlackMock;
}(BaseMock)),
  BotFramework: (function (BaseMock) {
  function BotFrameworkMock () {
      BaseMock.call(this);
      this.capNamePublishPort = Capabilities.BOTFRAMEWORK_PUBLISHPORT;
      this.capNamePublishPortRange = Capabilities.BOTFRAMEWORK_PUBLISHPORT_RANGE;
      this.packageDir = 'src/mocks/botframework';
      this.dockerFile = 'Dockerfile.botframeworkmock';
      this.dockerComposeFile = 'docker-compose.botframeworkmock.yml';
      this.debug = require$$0('botium-BotFrameworkMock');
    }

  if ( BaseMock ) BotFrameworkMock.__proto__ = BaseMock;
  BotFrameworkMock.prototype = Object.create( BaseMock && BaseMock.prototype );
  BotFrameworkMock.prototype.constructor = BotFrameworkMock;

    BotFrameworkMock.prototype.FillDockerEnv = function FillDockerEnv (composeEnv, caps, logging) {
      composeEnv.services['botium-botframeworkmock'] = {
        build: {
          context: this.mockDir
        },
        logging: _.cloneDeep(logging),
        volumes: [
          ((this.mockDir) + ":/usr/src/app")
        ],
        ports: [
          ((this.publishPort) + ":" + (this.publishPort))
        ],
        environment: {
          BOTIUM_BOTFRAMEWORK_WEBHOOKPORT: caps[Capabilities.BOTFRAMEWORK_WEBHOOK_PORT],
          BOTIUM_BOTFRAMEWORK_WEBHOOKPATH: caps[Capabilities.BOTFRAMEWORK_WEBHOOK_PATH],
          BOTIUM_BOTFRAMEWORK_APP_ID: caps[Capabilities.BOTFRAMEWORK_APP_ID],
          BOTIUM_BOTFRAMEWORK_CHANNEL_ID: caps[Capabilities.BOTFRAMEWORK_CHANNEL_ID],
          BOTIUM_BOTFRAMEWORK_PUBLISHPORT: this.publishPort
        }
      };
    };

  return BotFrameworkMock;
}(BaseMock))
};

function createErrorObject (err, message) {
  return {
    date: new Date(),
    error: err,
    message: message
  }
}

var SyslogServer_1 = (function (EventEmitter) {
  function SyslogServer () {
    EventEmitter.call(this);
    this.status = false;
    this.server = null;
  }

  if ( EventEmitter ) SyslogServer.__proto__ = EventEmitter;
  SyslogServer.prototype = Object.create( EventEmitter && EventEmitter.prototype );
  SyslogServer.prototype.constructor = SyslogServer;

  SyslogServer.prototype.start = function start (options, cb) {
    var this$1 = this;
    if ( options === void 0 ) options = { port: 514, address: '0.0.0.0', exclusive: true };

    return new Promise(function (resolve, reject) {
      if (this$1.status === true) {
        var errorObj = createErrorObject(null, 'NodeJS Syslog Server is already running!');
        if (cb) { return cb(errorObj) }
        return reject(errorObj)
      } else {
        this$1.server = dgram.createSocket('udp4');

        // Socket listening handler
        this$1.server.on('listening', function () {
          this$1.status = true;
          this$1.emit('start');
        });

        // Socket error handler
        this$1.server.on('error', function (err) {
          this$1.emit('error', err);
        });

        // Socket message handler
        this$1.server.on('message', function (msg, remote) {
          var message = {
            date: new Date(),
            host: remote.address,
            message: msg.toString('utf8'),
            protocol: remote.family
          };
          this$1.emit('message', message);
        });

        // Socket close handler
        this$1.server.on('close', function () {
          this$1.status = false;
          this$1.emit('stop');
        });

        this$1.server.bind(options, function (err) {
          if (err) {
            var errorObj = createErrorObject(err, 'NodeJS Syslog Server failed to start!');
            if (cb) { return cb(errorObj) }
            return reject(errorObj)
          } else {
            if (cb) { return cb() }
            return resolve()
          }
        });
      }
    })
  };

  SyslogServer.prototype.stop = function stop (cb) {
    var this$1 = this;

    return new Promise(function (resolve, reject) {
      try {
        this$1.server.close(function () {
          if (cb) { return cb() }
          return resolve()
        });
      } catch (err) {
        var errorObj = createErrorObject(err, 'NodeJS Syslog Server is not running!');
        if (cb) { return cb(errorObj) }
        return reject(errorObj)
      }
    })
  };

  SyslogServer.prototype.isRunning = function isRunning () {
    return this.status
  };

  return SyslogServer;
}(events));

var debug$8 = require$$0('botium-DockerContainer');
var debugContainerOutput = require$$0('botium-DockerContainerOutput');












var botiumPackageRootDir$1 = findRoot();

var DockerContainer_1 = (function (BaseContainer) {
  function DockerContainer () {
    BaseContainer.apply(this, arguments);
  }

  if ( BaseContainer ) DockerContainer.__proto__ = BaseContainer;
  DockerContainer.prototype = Object.create( BaseContainer && BaseContainer.prototype );
  DockerContainer.prototype.constructor = DockerContainer;

  DockerContainer.prototype.Validate = function Validate () {
    var this$1 = this;

    return BaseContainer.prototype.Validate.call(this).then(function () {
      this$1._AssertCapabilityExists(Capabilities.DOCKERCOMPOSEPATH);
      this$1._AssertCapabilityExists(Capabilities.STARTCMD);
      this$1._AssertCapabilityExists(Capabilities.DOCKERIMAGE);
      this$1._AssertOneCapabilityExists(Capabilities.DOCKERSYSLOGPORT, Capabilities.DOCKERSYSLOGPORT_RANGE);
      if (this$1.caps[Capabilities.DOCKERMACHINE]) {
        this$1._AssertCapabilityExists(Capabilities.DOCKERMACHINEPATH);
      }
      if (this$1.caps[Capabilities.FACEBOOK_API]) {
        this$1._AssertCapabilityExists(Capabilities.FACEBOOK_WEBHOOK_PORT);
        this$1._AssertCapabilityExists(Capabilities.FACEBOOK_WEBHOOK_PATH);
        this$1._AssertOneCapabilityExists(Capabilities.FACEBOOK_PUBLISHPORT, Capabilities.FACEBOOK_PUBLISHPORT_RANGE);
      }

      if (this$1.caps[Capabilities.SLACK_API]) {
        this$1._AssertCapabilityExists(Capabilities.SLACK_EVENT_PORT);
        this$1._AssertCapabilityExists(Capabilities.SLACK_EVENT_PATH);
        this$1._AssertCapabilityExists(Capabilities.SLACK_OAUTH_PORT);
        this$1._AssertCapabilityExists(Capabilities.SLACK_OAUTH_PATH);
        this$1._AssertOneCapabilityExists(Capabilities.SLACK_PUBLISHPORT, Capabilities.SLACK_PUBLISHPORT_RANGE);
      }

      if (this$1.caps[Capabilities.BOTFRAMEWORK_API]) {
        this$1._AssertCapabilityExists(Capabilities.BOTFRAMEWORK_APP_ID);
        this$1._AssertCapabilityExists(Capabilities.BOTFRAMEWORK_CHANNEL_ID);
        this$1._AssertCapabilityExists(Capabilities.BOTFRAMEWORK_WEBHOOK_PORT);
        this$1._AssertCapabilityExists(Capabilities.BOTFRAMEWORK_WEBHOOK_PATH);
        this$1._AssertOneCapabilityExists(Capabilities.BOTFRAMEWORK_PUBLISHPORT, Capabilities.BOTFRAMEWORK_PUBLISHPORT_RANGE);
      }
    })
  };

  DockerContainer.prototype.Build = function Build () {
    var this$1 = this;

    if (this.caps[Capabilities.FACEBOOK_API]) {
      debug$8('Adding Facebook Mock to Docker compose');
      this.fbMock = new DockerMocks.Facebook();
    }
    if (this.caps[Capabilities.SLACK_API]) {
      debug$8('Adding Slack Mock to Docker compose');
      this.slackMock = new DockerMocks.Slack();
    }
    if (this.caps[Capabilities.BOTFRAMEWORK_API]) {
      debug$8('Adding BotFramework Mock to Docker compose');
      this.botframeworkMock = new DockerMocks.BotFramework();
    }

    return new Promise(function (resolve, reject) {
      this$1.dockerConfig = {
        projectname: this$1.caps[Capabilities.PROJECTNAME],
        dockercomposepath: this$1.caps[Capabilities.DOCKERCOMPOSEPATH],
        uniquecontainernames: this$1.caps[Capabilities.DOCKERUNIQUECONTAINERNAMES],
        composefiles: []
      };

      async.series([

        function (baseComplete) {
          BaseContainer.prototype.Build.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        },

        function (dockerIpFound) {
          if (this$1.caps[Capabilities.DOCKERMACHINE]) {
            ProcessUtils.childProcessRun(this$1.caps[Capabilities.DOCKERMACHINEPATH], [ 'ip' ], false)
              .then(function (output) {
                if (output.stdout && output.stdout.length > 0) {
                  this$1.dockerIp = ("" + (output.stdout[0])).trim();
                  if (this$1.dockerIp) {
                    debug$8(("Found docker-machine ip " + (this$1.dockerIp) + "."));
                    return dockerIpFound()
                  }
                }
                dockerIpFound(("No docker-machine ip found in command output " + output));
              }).catch(dockerIpFound);
          } else {
            this$1.dockerIp = '127.0.0.1';
            dockerIpFound();
          }
        },

        function (dockerfileCreated) {
          var dockerfileBotium = path.resolve(this$1.repo.workingDirectory, 'Dockerfile.botium');
          fs.stat(dockerfileBotium, function (err, stats) {
            if (!err && stats.isFile()) {
              debug$8(("Dockerfile " + dockerfileBotium + " already present, using it."));
              dockerfileCreated();
            } else {
              var templateFile = path.resolve(botiumPackageRootDir$1, 'src', 'Dockerfile.botium.template');
              fs.readFile(templateFile, 'utf8', function (err, data) {
                if (err) { return dockerfileCreated(("Reading docker template file " + templateFile + " failed: " + err)) }
                var viewData = {
                  STARTCMD: this$1.caps[Capabilities.STARTCMD],
                  DOCKERIMAGE: this$1.caps[Capabilities.DOCKERIMAGE]
                };
                var convertedFile = mustache.render(data, viewData);
                fs.writeFile(dockerfileBotium, convertedFile, function (err) {
                  if (err) { return dockerfileCreated(("Writing dockerfile " + dockerfileBotium + " failed: " + err)) }

                  this$1.cleanupTasks.push(function (cb) {
                    fs.stat(dockerfileBotium, function (err, stats) {
                      if (!err && stats.isFile()) {
                        fs.unlink(dockerfileBotium, cb);
                      } else {
                        cb();
                      }
                    });
                  });
                  dockerfileCreated();
                });
              });
            }
          });
        },

        function (dockercomposeMainUsed) {
          var dockercomposeMain = path.resolve(botiumPackageRootDir$1, 'src', 'docker-compose.botium.yml');
          var dockercomposeBotium = path.resolve(this$1.tempDirectory, 'docker-compose.botium.yml');

          SafeFileCopy(dockercomposeMain, dockercomposeBotium)
            .then(function () {
              this$1.dockerConfig.composefiles.push(dockercomposeBotium);
              dockercomposeMainUsed();
            })
            .catch(function (err) { return dockercomposeMainUsed(("Copying docker compose template file " + dockercomposeMain + " failed: " + err)); });
        },

        function (syslogPortSelected) {
          if (this$1.caps[Capabilities.DOCKERSYSLOGPORT]) {
            this$1.syslogPort = this$1.caps[Capabilities.DOCKERSYSLOGPORT];
            if (this$1.caps[Capabilities.BOTIUMGRIDSLOT]) {
              this$1.publishPort += this$1.caps[Capabilities.BOTIUMGRIDSLOT];
            }
            syslogPortSelected();
          } else {
            TcpPortUtils.GetFreePortInRange('127.0.0.1', this$1.caps[Capabilities.DOCKERSYSLOGPORT_RANGE])
              .then(function (syslogPort) {
                this$1.syslogPort = syslogPort;
                syslogPortSelected();
              })
              .catch(syslogPortSelected);
          }
        },

        function (facebookPortSelected) {
          if (this$1.fbMock) {
            this$1.fbMock.SelectPublishPort(this$1.dockerIp, this$1.caps).then(function () { return facebookPortSelected(); }).catch(facebookPortSelected);
          } else {
            facebookPortSelected();
          }
        },

        function (slackPortSelected) {
          if (this$1.slackMock) {
            this$1.slackMock.SelectPublishPort(this$1.dockerIp, this$1.caps).then(function () { return slackPortSelected(); }).catch(slackPortSelected);
          } else {
            slackPortSelected();
          }
        },

        function (botframeworkPortSelected) {
          if (this$1.botframeworkMock) {
            this$1.botframeworkMock.SelectPublishPort(this$1.dockerIp, this$1.caps).then(function () { return botframeworkPortSelected(); }).catch(botframeworkPortSelected);
          } else {
            botframeworkPortSelected();
          }
        },

        function (facebookMockPrepared) {
          if (this$1.fbMock) {
            this$1.fbMock.PrepareDocker(path.resolve(this$1.tempDirectory, 'fbmock')).then(function () { return facebookMockPrepared(); }).catch(facebookMockPrepared);
          } else {
            facebookMockPrepared();
          }
        },

        function (slackMockPrepared) {
          if (this$1.slackMock) {
            this$1.slackMock.PrepareDocker(path.resolve(this$1.tempDirectory, 'slackmock')).then(function () { return slackMockPrepared(); }).catch(slackMockPrepared);
          } else {
            slackMockPrepared();
          }
        },

        function (botframeworkMockPrepared) {
          if (this$1.botframeworkMock) {
            this$1.botframeworkMock.PrepareDocker(path.resolve(this$1.tempDirectory, 'botframeworkmock')).then(function () { return botframeworkMockPrepared(); }).catch(botframeworkMockPrepared);
          } else {
            botframeworkMockPrepared();
          }
        },

        function (dockercomposeUsed) {
          var promises = [];
          if (this$1.fbMock) {
            promises.push(this$1.fbMock.GetDockerCompose().then(function (f) {
              this$1.dockerConfig.composefiles.push(f);
            }));
          }
          if (this$1.slackMock) {
            promises.push(this$1.slackMock.GetDockerCompose().then(function (f) {
              this$1.dockerConfig.composefiles.push(f);
            }));
          }
          if (this$1.botframeworkMock) {
            promises.push(this$1.botframeworkMock.GetDockerCompose().then(function (f) {
              this$1.dockerConfig.composefiles.push(f);
            }));
          }
          Promise.all(promises).then(function () { return dockercomposeUsed(); });
        },

        function (dockercomposeEnvUsed) {
          var sysLog = {
            driver: 'syslog',
            options: {
              'syslog-address': ("udp://127.0.0.1:" + (this$1.syslogPort))
            }
          };

          var composeEnv = {
            version: '2',
            services: {
              botium: {
                build: {
                  context: this$1.repo.workingDirectory
                },
                logging: _.cloneDeep(sysLog),
                volumes: [
                  ((this$1.repo.workingDirectory) + ":/usr/src/app")
                ]
              }
            }
          };
          if (this$1.envs) {
            composeEnv.services.botium.environment = this$1._cleanDockerEnv(this$1.envs);
          }
          if (this$1.fbMock) {
            this$1.fbMock.FillDockerEnv(composeEnv, this$1.caps, sysLog);
          }
          if (this$1.slackMock) {
            this$1.slackMock.FillDockerEnv(composeEnv, this$1.caps, sysLog);
          }
          if (this$1.botframeworkMock) {
            this$1.botframeworkMock.FillDockerEnv(composeEnv, this$1.caps, sysLog);
          }

          this$1.dockercomposeEnvFile = path.resolve(this$1.tempDirectory, "docker-env.yml");

          debug$8(("Writing docker compose environment to " + (this$1.dockercomposeEnvFile) + " - " + (JSON.stringify(composeEnv))));
          writeYaml(this$1.dockercomposeEnvFile, composeEnv, function (err) {
            if (err) { return dockercomposeEnvUsed(("Writing docker file " + (this$1.dockercomposeEnvFile) + " failed: " + err)) }
            this$1.dockerConfig.composefiles.push(this$1.dockercomposeEnvFile);
            dockercomposeEnvUsed();
          });
        },

        function (dockercomposeOverrideUsed) {
          var dockercomposeOverride = path.resolve(this$1.repo.workingDirectory, 'docker-compose.botium.override.yml');
          fs.stat(dockercomposeOverride, function (err, stats) {
            if (!err && stats.isFile()) {
              debug$8(("Docker-Compose file " + dockercomposeOverride + " present, using it."));
              this$1.dockerConfig.composefiles.push(dockercomposeOverride);
            }
            dockercomposeOverrideUsed();
          });
        },

        function (dockercomposeLocalOverrideUsed) {
          var dockercomposeOverride = path.resolve(process.cwd(), 'docker-compose.botium.override.yml');
          fs.stat(dockercomposeOverride, function (err, stats) {
            if (!err && stats.isFile()) {
              debug$8(("Docker-Compose file " + dockercomposeOverride + " present, using it."));
              this$1.dockerConfig.composefiles.push(dockercomposeOverride);
            }
            dockercomposeLocalOverrideUsed();
          });
        },

        function (dockerReady) {
          this$1.dockerConfig.composefiles = _.uniq(this$1.dockerConfig.composefiles);
          debug$8(this$1.dockerConfig);
          this$1.dockerCmd = new DockerCmd_1(this$1.dockerConfig);
          this$1.dockerCmd.setupContainer()
            .then(function () {
              dockerReady();
            })
            .catch(function (err) {
              dockerReady(("Cannot build docker containers: " + (util.inspect(err))));
            });
        }

      ], function (err) {
        if (err) {
          return reject(new Error(("Cannot build docker containers: " + (util.inspect(err)))))
        }
        resolve(this$1);
      });
    })
  };

  DockerContainer.prototype.Start = function Start () {
    var this$1 = this;

    this.eventEmitter.emit(Events.CONTAINER_STARTING, this);

    return new Promise(function (resolve, reject) {
      async.series([

        function (baseComplete) {
          BaseContainer.prototype.Start.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        },

        function (syslogStarted) {
          var waitFor = Promise.resolve();
          if (this$1.syslogServer) {
            waitFor = this$1.syslogServer.stop();
          }
          waitFor.then(function () {
            this$1.syslogFile = path.resolve(this$1.tempDirectory, 'docker-containers-log.txt');

            this$1.syslogServer = new SyslogServer_1();

            this$1.syslogServer.on('message', function (value) {
              debugContainerOutput(value.message);
              fs.appendFile(this$1.syslogFile, value.message, function () { });
            });
            this$1.syslogServer.on('error', function (err) {
              debug$8(("Error from syslog server: " + (util.inspect(err))));
            });
            this$1.syslogServer.start({ port: this$1.syslogPort })
              .then(function () { return syslogStarted(); })
              .catch(function (err) {
                syslogStarted(("Cannot start syslog server: " + (util.inspect(err))));
              });
          }).catch(function (err) {
            syslogStarted(("Cannot stop running syslog server: " + (util.inspect(err))));
          });
        },

        function (dockerStarted) {
          if (!this$1.dockerCmd) { return dockerStarted('not built') }

          this$1.dockerCmd.startContainer()
            .then(function () { return dockerStarted(); })
            .catch(function (err) {
              dockerStarted(("Cannot start docker containers: " + (util.inspect(err))));
            });
        },

        function (facebookMockupOnline) {
          if (this$1.fbMock) {
            this$1.fbMock.Start(this$1).then(function () { return facebookMockupOnline(); }).catch(facebookMockupOnline);
          } else {
            facebookMockupOnline();
          }
        },

        function (slackMockupOnline) {
          if (this$1.slackMock) {
            this$1.slackMock.Start(this$1).then(function () { return slackMockupOnline(); }).catch(slackMockupOnline);
          } else {
            slackMockupOnline();
          }
        },

        function (botframeworkMockupOnline) {
          if (this$1.botframeworkMock) {
            this$1.botframeworkMock.Start(this$1).then(function () { return botframeworkMockupOnline(); }).catch(botframeworkMockupOnline);
          } else {
            botframeworkMockupOnline();
          }
        }

      ], function (err) {
        if (err) {
          this$1.eventEmitter.emit(Events.CONTAINER_START_ERROR, this$1, err);
          return reject(new Error(("Start failed " + (util.inspect(err)))))
        }
        this$1.eventEmitter.emit(Events.CONTAINER_STARTED, this$1);
        resolve(this$1);
      });
    })
  };

  DockerContainer.prototype.UserSays = function UserSays (mockMsg) {
    var this$1 = this;

    return new Promise(function (resolve, reject) {
      if (this$1.fbMock && this$1.fbMock.socket) {
        this$1.fbMock.socket.emit(BotiumMockCommand.MOCKCMD_SENDTOBOT, mockMsg);
        this$1.eventEmitter.emit(Events.MESSAGE_SENTTOBOT, this$1, mockMsg);
        resolve(this$1);
      } else if (this$1.slackMock && this$1.slackMock.socket) {
        this$1.slackMock.socket.emit(BotiumMockCommand.MOCKCMD_SENDTOBOT, mockMsg);
        this$1.eventEmitter.emit(Events.MESSAGE_SENTTOBOT, this$1, mockMsg);
        resolve(this$1);
      } else if (this$1.botframeworkMock && this$1.botframeworkMock.socket) {
        this$1.botframeworkMock.socket.emit(BotiumMockCommand.MOCKCMD_SENDTOBOT, mockMsg);
        this$1.eventEmitter.emit(Events.MESSAGE_SENTTOBOT, this$1, mockMsg);
        resolve(this$1);
      } else {
        this$1.eventEmitter.emit(Events.MESSAGE_SENDTOBOT_ERROR, this$1, 'No Mock online');
        reject(new Error('No Mock online'));
      }
    })
  };

  DockerContainer.prototype.Stop = function Stop () {
    var this$1 = this;

    this.eventEmitter.emit(Events.CONTAINER_STOPPING, this);

    return new Promise(function (resolve, reject) {
      async.series([

        function (baseComplete) {
          BaseContainer.prototype.Stop.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        },

        function (facebookStopDone) {
          if (this$1.fbMock) {
            this$1.fbMock.Stop().then(function () { return facebookStopDone(); }).catch(facebookStopDone);
          } else {
            facebookStopDone();
          }
        },

        function (slackStopDone) {
          if (this$1.slackMock) {
            this$1.slackMock.Stop().then(function () { return slackStopDone(); }).catch(slackStopDone);
          } else {
            slackStopDone();
          }
        },

        function (botframeworkStopDone) {
          if (this$1.botframeworkMock) {
            this$1.botframeworkMock.Stop(this$1).then(function () { return botframeworkStopDone(); }).catch(botframeworkStopDone);
          } else {
            botframeworkStopDone();
          }
        },

        function (dockerStopped) {
          if (!this$1.dockerCmd) { return dockerStopped() }

          this$1.dockerCmd.stopContainer()
            .then(function () {
              dockerStopped();
            })
            .catch(function (err) {
              dockerStopped(("Cannot stop docker containers: " + (util.inspect(err))));
            });
        },

        function (syslogStopped) {
          if (!this$1.syslogServer) { return syslogStopped() }

          this$1.syslogServer.stop()
            .then(function () {
              this$1.syslogServer = null;
              syslogStopped();
            })
            .catch(function (err) {
              syslogStopped(("Cannot stop syslog server: " + (util.inspect(err))));
            });
        }

      ], function (err) {
        if (err) {
          this$1.eventEmitter.emit(Events.CONTAINER_STOP_ERROR, this$1, err);
          return reject(new Error(("Stop failed " + (util.inspect(err)))))
        }
        this$1.eventEmitter.emit(Events.CONTAINER_STOPPED, this$1);
        resolve(this$1);
      });
    })
  };

  DockerContainer.prototype.Clean = function Clean () {
    var this$1 = this;

    this.eventEmitter.emit(Events.CONTAINER_CLEANING, this);

    return new Promise(function (resolve, reject) {
      async.series([

        function (dockerStopped) {
          if (this$1.dockerCmd) {
            this$1.dockerCmd.teardownContainer()
              .then(function () {
                dockerStopped();
              })
              .catch(function (err) {
                debug$8(("Cannot teardown docker containers: " + (util.inspect(err))));
                dockerStopped();
              });
          } else {
            dockerStopped();
          }
        },

        function (baseComplete) {
          BaseContainer.prototype.Clean.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        }

      ], function (err) {
        if (err) {
          this$1.eventEmitter.emit(Events.CONTAINER_CLEAN_ERROR, this$1, err);
          return reject(new Error(("Cleanup failed " + (util.inspect(err)))))
        }
        this$1.eventEmitter.emit(Events.CONTAINER_CLEANED, this$1);
        resolve(this$1);
      });
    })
  };

  DockerContainer.prototype._cleanDockerEnv = function _cleanDockerEnv (envs) {
    var res = Object.assign({}, envs);
    Object.keys(res).forEach(function (key) {
      var val = res[key];
      if (typeof val === typeof true) { res[key] = "" + val; }
    });
    return res
  };

  return DockerContainer;
}(BaseContainer_1));

var debug$9 = require$$0('botium-FbContainer');
var debugApi = require$$0('botium-FbContainer-Api');






var FbContainer_1 = (function (BaseContainer) {
  function FbContainer () {
    BaseContainer.apply(this, arguments);
  }

  if ( BaseContainer ) FbContainer.__proto__ = BaseContainer;
  FbContainer.prototype = Object.create( BaseContainer && BaseContainer.prototype );
  FbContainer.prototype.constructor = FbContainer;

  FbContainer.prototype.Validate = function Validate () {
    var this$1 = this;

    return BaseContainer.prototype.Validate.call(this).then(function () {
      this$1._AssertCapabilityExists(Capabilities.FB_PAGEID);
      this$1._AssertCapabilityExists(Capabilities.FB_USER);
      this$1._AssertCapabilityExists(Capabilities.FB_PASSWORD);
    })
  };

  FbContainer.prototype.Build = function Build () {
    var this$1 = this;

    return new Promise(function (resolve, reject) {
      async.series([
        function (baseComplete) {
          BaseContainer.prototype.Build.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        },

        function (fbLoginReady) {
          this$1.fbapi = null;
          debug$9(("logging into facebook page " + (this$1.caps[Capabilities.FB_PAGEID]) + " with user " + (this$1.caps[Capabilities.FB_USER])));
          facebookChatApi({ email: this$1.caps[Capabilities.FB_USER], password: this$1.caps[Capabilities.FB_PASSWORD] }, { logLevel: debugApi.enabled ? 'verbose' : 'warn' }, function (err, api) {
            if (err) {
              fbLoginReady(("Facebook login failed: " + (util.inspect(err))));
            } else {
              debug$9('logging into facebook ready');
              this$1.fbapi = api;
              fbLoginReady();
            }
          });
        }
      ], function (err) {
        if (err) {
          return reject(new Error(("Cannot build facebook container: " + (util.inspect(err)))))
        }
        resolve(this$1);
      });
    })
  };

  FbContainer.prototype.Start = function Start () {
    var this$1 = this;

    if (!this.fbapi) { return Promise.reject(new Error('not built')) }

    this.eventEmitter.emit(Events.CONTAINER_STARTING, this);

    return new Promise(function (resolve, reject) {
      async.series([
        function (baseComplete) {
          BaseContainer.prototype.Start.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        },

        function (startListenerDone) {
          if (this$1.fbapiStopListener) {
            this$1.fbapiStopListener();
            this$1.fbapiStopListener = null;
          }
          this$1.fbapiStopListener = this$1.fbapi.listen(function (err, event) {
            if (err) {
              debug$9(("fbapi Error: " + (util.inspect(err))));
            } else if (event.type === 'message') {
              debug$9(("fbapi received message: " + (util.inspect(event))));
              var botMsg = { sourceData: event };
              if (event.body) {
                botMsg.messageText = event.body;
              }
              this$1._QueueBotSays(new BotiumMockMessage_1(botMsg));
            } else {
              debug$9(("fbapi received ignored event: " + (util.inspect(event))));
            }
          });
          startListenerDone();
        }
      ], function (err) {
        if (err) {
          this$1.eventEmitter.emit(Events.CONTAINER_START_ERROR, this$1, err);
          return reject(new Error(("Start failed " + (util.inspect(err)))))
        }
        this$1.eventEmitter.emit(Events.CONTAINER_STARTED, this$1);
        resolve(this$1);
      });
    })
  };

  FbContainer.prototype.UserSays = function UserSays (mockMsg) {
    if (!this.fbapi) { return Promise.reject(new Error('not built')) }

    this.fbapi.sendMessage(mockMsg.messageText, this.caps[Capabilities.FB_PAGEID]);
    this.eventEmitter.emit(Events.MESSAGE_SENTTOBOT, this, mockMsg);
    return Promise.resolve(this)
  };

  FbContainer.prototype.Stop = function Stop () {
    var this$1 = this;

    if (!this.fbapi) { return Promise.reject(new Error('not built')) }

    this.eventEmitter.emit(Events.CONTAINER_STOPPING, this);

    return new Promise(function (resolve, reject) {
      async.series([
        function (baseComplete) {
          BaseContainer.prototype.Stop.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        },

        function (stopListenerDone) {
          if (this$1.fbapiStopListener) {
            this$1.fbapiStopListener();
            this$1.fbapiStopListener = null;
          }
          stopListenerDone();
        }

      ], function (err) {
        if (err) {
          this$1.eventEmitter.emit(Events.CONTAINER_STOP_ERROR, this$1, err);
          return reject(new Error(("Stop failed " + (util.inspect(err)))))
        }
        this$1.eventEmitter.emit(Events.CONTAINER_STOPPED, this$1);
        resolve(this$1);
      });
    })
  };

  FbContainer.prototype.Clean = function Clean () {
    var this$1 = this;

    if (!this.fbapi) { return Promise.reject(new Error('not built')) }

    this.eventEmitter.emit(Events.CONTAINER_CLEANING, this);

    return new Promise(function (resolve, reject) {
      async.series([

        function (fbLogoutReady) {
          if (this$1.fbapi) {
            this$1.fbapi.logout(function (err) {
              debug$9(("logging out of facebook ready (" + (util.inspect(err)) + ")"));
              this$1.fbapi = null;
              fbLogoutReady();
            });
          } else {
            fbLogoutReady();
          }
        },

        function (baseComplete) {
          BaseContainer.prototype.Clean.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        }

      ], function (err) {
        if (err) {
          this$1.eventEmitter.emit(Events.CONTAINER_CLEAN_ERROR, this$1, err);
          return reject(new Error(("Cleanup failed " + (util.inspect(err)))))
        }
        this$1.eventEmitter.emit(Events.CONTAINER_CLEANED, this$1);
        resolve(this$1);
      });
    })
  };

  return FbContainer;
}(BaseContainer_1));

var debug$10 = require$$0('botium-WatsonConversationContainer');






var WatsonConversationContainer_1 = (function (BaseContainer) {
  function WatsonConversationContainer () {
    BaseContainer.apply(this, arguments);
  }

  if ( BaseContainer ) WatsonConversationContainer.__proto__ = BaseContainer;
  WatsonConversationContainer.prototype = Object.create( BaseContainer && BaseContainer.prototype );
  WatsonConversationContainer.prototype.constructor = WatsonConversationContainer;

  WatsonConversationContainer.prototype.Validate = function Validate () {
    var this$1 = this;

    return BaseContainer.prototype.Validate.call(this).then(function () {
      this$1._AssertCapabilityExists(Capabilities.WATSONCONVERSATION_URL);
      this$1._AssertCapabilityExists(Capabilities.WATSONCONVERSATION_VERSION_DATE);
      this$1._AssertCapabilityExists(Capabilities.WATSONCONVERSATION_USER);
      this$1._AssertCapabilityExists(Capabilities.WATSONCONVERSATION_PASSWORD);
      this$1._AssertCapabilityExists(Capabilities.WATSONCONVERSATION_WORKSPACE_ID);
    })
  };

  WatsonConversationContainer.prototype.Build = function Build () {
    var this$1 = this;

    return new Promise(function (resolve, reject) {
      async.series([
        function (baseComplete) {
          BaseContainer.prototype.Build.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        },

        function (conversationReady) {
          this$1.conversation = new v1({
            url: this$1.caps[Capabilities.WATSONCONVERSATION_URL],
            username: this$1.caps[Capabilities.WATSONCONVERSATION_USER],
            password: this$1.caps[Capabilities.WATSONCONVERSATION_PASSWORD],
            version_date: this$1.caps[Capabilities.WATSONCONVERSATION_VERSION_DATE]
          });
          conversationReady();
        },

        function (workspaceCopied) {
          if (this$1.caps[Capabilities.WATSONCONVERSATION_COPY_WORKSPACE]) {
            this$1.conversation.getWorkspace({ workspace_id: this$1.caps[Capabilities.WATSONCONVERSATION_WORKSPACE_ID], export: true }, function (err, workspace) {
              if (err) {
                workspaceCopied(("Watson workspace connection failed: " + (util.inspect(err))));
              } else {
                this$1.conversation.createWorkspace(workspace, function (err, workspaceCopy) {
                  if (err) {
                    workspaceCopied(("Watson workspace copy failed: " + (util.inspect(err))));
                  } else {
                    debug$10(("Watson workspace copied: " + (util.inspect(workspaceCopy))));
                    this$1.useWorkspaceId = workspaceCopy.workspace_id;
                    workspaceCopied();
                  }
                });
              }
            });
          } else {
            this$1.useWorkspaceId = this$1.caps[Capabilities.WATSONCONVERSATION_WORKSPACE_ID];
            workspaceCopied();
          }
        },

        function (workspaceAvailableReady) {
          var workspaceAvailable = false;

          async.until(
            function () { return workspaceAvailable; },
            function (workspaceChecked) {
              debug$10(("Watson checking workspace status " + (this$1.useWorkspaceId) + " before proceed"));

              this$1.conversation.getWorkspace({ workspace_id: this$1.useWorkspaceId }, function (err, workspace) {
                if (err) {
                  workspaceChecked(("Watson workspace connection failed: " + (util.inspect(err))));
                } else {
                  debug$10(("Watson workspace connected, checking for status 'Available': " + (util.inspect(workspace))));
                  if (workspace.status === 'Available') {
                    workspaceAvailable = true;
                    workspaceChecked();
                  } else {
                    debug$10("Watson workspace waiting for status 'Available'");
                    setTimeout(workspaceChecked, 10000);
                  }
                }
              });
            },
            function (err) {
              if (err) { return workspaceAvailableReady(err) }
              workspaceAvailableReady();
            });
        }

      ], function (err) {
        if (err) {
          return reject(new Error(("Cannot build watson container: " + (util.inspect(err)))))
        }
        resolve(this$1);
      });
    })
  };

  WatsonConversationContainer.prototype.Start = function Start () {
    var this$1 = this;

    if (!this.conversation) { return Promise.reject(new Error('not built')) }

    this.eventEmitter.emit(Events.CONTAINER_STARTING, this);

    return BaseContainer.prototype.Start.call(this).then(function () {
      this$1.conversationContext = {};
      this$1.eventEmitter.emit(Events.CONTAINER_STARTED, this$1);
      return this$1
    })
  };

  WatsonConversationContainer.prototype.UserSays = function UserSays (mockMsg) {
    var this$1 = this;

    if (!this.conversation) { return Promise.reject(new Error('not built')) }

    return new Promise(function (resolve, reject) {
      var payload = {
        workspace_id: this$1.useWorkspaceId,
        context: this$1.conversationContext || {},
        input: { text: mockMsg.messageText }
      };
      if (this$1.caps[Capabilities.WATSONCONVERSATION_USE_INTENT]) {
        payload.alternate_intents = true;
      }
      this$1.conversation.message(payload, function (err, data) {
        if (err) { return reject(new Error(("Cannot send message to watson container: " + (util.inspect(err))))) }

        debug$10(("Watson response: " + (util.inspect(data))));
        this$1.conversationContext = data.context;
        this$1.eventEmitter.emit(Events.MESSAGE_SENTTOBOT, this$1, mockMsg);

        if (this$1.caps[Capabilities.WATSONCONVERSATION_USE_INTENT]) {
          if (data.intents.length > 1 && data.intents[0].confidence === data.intents[1].confidence) {
            return reject(new Error(("Got duplicate intent confidence " + (util.inspect(data.intents[0])) + " vs " + (util.inspect(data.intents[1])))))
          }
        }
        resolve(this$1);

        if (this$1.caps[Capabilities.WATSONCONVERSATION_USE_INTENT]) {
          if (data.intents && data.intents.length > 0) {
            var botMsg = { sender: 'bot', sourceData: data, messageText: data.intents[0].intent };
            this$1._QueueBotSays(new BotiumMockMessage_1(botMsg));
          }
        } else {
          if (data.output && data.output.text) {
            var messageTexts = (_.isArray(data.output.text) ? data.output.text : [ data.output.text ]);

            messageTexts.forEach(function (messageText) {
              if (!messageText) { return }

              var botMsg = { sender: 'bot', sourceData: data, messageText: messageText };
              this$1._QueueBotSays(new BotiumMockMessage_1(botMsg));
            });
          }
        }
      });
    })
  };

  WatsonConversationContainer.prototype.Stop = function Stop () {
    var this$1 = this;

    if (!this.conversation) { return Promise.reject(new Error('not built')) }

    this.eventEmitter.emit(Events.CONTAINER_STOPPING, this);

    return BaseContainer.prototype.Stop.call(this).then(function () {
      this$1.eventEmitter.emit(Events.CONTAINER_STOPPED, this$1);
      return this$1
    })
  };

  WatsonConversationContainer.prototype.Clean = function Clean () {
    var this$1 = this;

    if (!this.conversation) { return Promise.reject(new Error('not built')) }

    this.eventEmitter.emit(Events.CONTAINER_CLEANING, this);

    return new Promise(function (resolve, reject) {
      async.series([

        function (workspaceDeleteReady) {
          if (this$1.caps[Capabilities.WATSONCONVERSATION_COPY_WORKSPACE]) {
            this$1.conversation.deleteWorkspace({ workspace_id: this$1.useWorkspaceId }, function (err) {
              if (err) {
                debug$10(("Watson workspace delete copy failed: " + (util.inspect(err))));
              } else {
                debug$10(("Watson workspace deleted: " + (this$1.useWorkspaceId)));
              }
              workspaceDeleteReady();
            });
          } else {
            workspaceDeleteReady();
          }
        },

        function (conversationReset) {
          this$1.conversation = null;
          this$1.conversationContext = null;
          conversationReset();
        },

        function (baseComplete) {
          BaseContainer.prototype.Clean.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        }

      ], function (err) {
        if (err) {
          this$1.eventEmitter.emit(Events.CONTAINER_CLEAN_ERROR, this$1, err);
          return reject(new Error(("Cleanup failed " + (util.inspect(err)))))
        }
        this$1.eventEmitter.emit(Events.CONTAINER_CLEANED, this$1);
        resolve(this$1);
      });
    })
  };

  return WatsonConversationContainer;
}(BaseContainer_1));

var debug$11 = require$$0('botium-SimpleRestContainer');






var SimpleRestContainer_1 = (function (BaseContainer) {
  function SimpleRestContainer () {
    BaseContainer.apply(this, arguments);
  }

  if ( BaseContainer ) SimpleRestContainer.__proto__ = BaseContainer;
  SimpleRestContainer.prototype = Object.create( BaseContainer && BaseContainer.prototype );
  SimpleRestContainer.prototype.constructor = SimpleRestContainer;

  SimpleRestContainer.prototype.Validate = function Validate () {
    var this$1 = this;

    return BaseContainer.prototype.Validate.call(this).then(function () {
      this$1._AssertCapabilityExists(Capabilities.SIMPLEREST_URL);
      this$1._AssertCapabilityExists(Capabilities.SIMPLEREST_METHOD);
      this$1._AssertCapabilityExists(Capabilities.SIMPLEREST_RESPONSE_JSONPATH);

      if (this$1.caps[Capabilities.SIMPLEREST_INIT_CONTEXT]) {
        JSON.parse(this$1.caps[Capabilities.SIMPLEREST_INIT_CONTEXT]);
      }
    })
  };

  SimpleRestContainer.prototype.Build = function Build () {
    var this$1 = this;

    return new Promise(function (resolve, reject) {
      async.series([
        function (baseComplete) {
          BaseContainer.prototype.Build.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        }

      ], function (err) {
        if (err) {
          return reject(new Error(("Cannot build simplereset container: " + (util.inspect(err)))))
        }
        resolve(this$1);
      });
    })
  };

  SimpleRestContainer.prototype.Start = function Start () {
    var this$1 = this;

    this.eventEmitter.emit(Events.CONTAINER_STARTING, this);

    return new Promise(function (resolve, reject) {
      async.series([
        function (baseComplete) {
          BaseContainer.prototype.Start.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        },

        function (contextInitComplete) {
          this$1.view = {
            context: { },
            msg: { }
          };
          if (this$1.caps[Capabilities.SIMPLEREST_INIT_CONTEXT]) {
            try {
              this$1.view.context = JSON.parse(this$1.caps[Capabilities.SIMPLEREST_INIT_CONTEXT]);
            } catch (err) {
              contextInitComplete(("parsing SIMPLEREST_INIT_CONTEXT failed, no JSON detected (" + (util.inspect(err)) + ")"));
            }
          }
          contextInitComplete();
        },

        function (initComplete) {
          if (this$1.caps[Capabilities.SIMPLEREST_INIT_TEXT]) {
            this$1._doRequest({ messageText: this$1.caps[Capabilities.SIMPLEREST_INIT_TEXT] }, false).then(function () { return initComplete(); }).catch(initComplete);
          } else {
            initComplete();
          }
        }
      ], function (err) {
        if (err) {
          this$1.eventEmitter.emit(Events.CONTAINER_START_ERROR, this$1, err);
          return reject(new Error(("Start failed " + (util.inspect(err)))))
        }
        this$1.eventEmitter.emit(Events.CONTAINER_STARTED, this$1);
        resolve(this$1);
      });
    })
  };

  SimpleRestContainer.prototype.UserSays = function UserSays (mockMsg) {
    return this._doRequest(mockMsg, true)
  };

  SimpleRestContainer.prototype.Stop = function Stop () {
    var this$1 = this;

    this.eventEmitter.emit(Events.CONTAINER_STOPPING, this);

    return new Promise(function (resolve, reject) {
      async.series([
        function (baseComplete) {
          BaseContainer.prototype.Stop.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        }
      ], function (err) {
        if (err) {
          this$1.eventEmitter.emit(Events.CONTAINER_STOP_ERROR, this$1, err);
          return reject(new Error(("Stop failed " + (util.inspect(err)))))
        }
        this$1.eventEmitter.emit(Events.CONTAINER_STOPPED, this$1);
        resolve(this$1);
      });
    })
  };

  SimpleRestContainer.prototype.Clean = function Clean () {
    var this$1 = this;

    this.eventEmitter.emit(Events.CONTAINER_CLEANING, this);

    return new Promise(function (resolve, reject) {
      async.series([
        function (baseComplete) {
          BaseContainer.prototype.Clean.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        }

      ], function (err) {
        if (err) {
          this$1.eventEmitter.emit(Events.CONTAINER_CLEAN_ERROR, this$1, err);
          return reject(new Error(("Cleanup failed " + (util.inspect(err)))))
        }
        this$1.eventEmitter.emit(Events.CONTAINER_CLEANED, this$1);
        resolve(this$1);
      });
    })
  };

  SimpleRestContainer.prototype._doRequest = function _doRequest (msg, evalResponseBody) {
    var this$1 = this;

    return new Promise(function (resolve, reject) {
      var requestOptions = this$1._buildRequest(msg);
      debug$11(("constructed requestOptions " + (util.inspect(requestOptions))));

      request(requestOptions, function (err, response, body) {
        if (err) {
          reject(new Error(("rest request failed: " + (util.inspect(err)))));
        } else {
          this$1.eventEmitter.emit(Events.MESSAGE_SENTTOBOT, this$1, msg);

          if (response.statusCode >= 400) {
            debug$11(("got error response: " + (response.statusCode) + "/" + (response.statusMessage)));
            return reject(new Error(("got error response: " + (response.statusCode) + "/" + (response.statusMessage))))
          }

          if (body) {
            debug$11(("got response body: " + (util.inspect(body))));

            if (this$1.caps[Capabilities.SIMPLEREST_CONTEXT_JSONPATH]) {
              var contextNodes = jsonpath.query(body, this$1.caps[Capabilities.SIMPLEREST_CONTEXT_JSONPATH]);
              if (_.isArray(contextNodes) && contextNodes.length > 0) {
                this$1.view.context = contextNodes[0];
                debug$11(("found context: " + (util.inspect(this$1.view.context))));
              } else {
                this$1.view.context = {};
              }
            } else {
              this$1.view.context = body;
            }

            if (evalResponseBody) {
              var jsonPathCaps = _.pickBy(this$1.caps, function (v, k) { return k.startsWith(Capabilities.SIMPLEREST_RESPONSE_JSONPATH); });
              _(jsonPathCaps).keys().sort().each(function (key) {
                var jsonPath = this$1.caps[key];
                debug$11(("eval json path " + jsonPath));

                var responseTexts = jsonpath.query(body, jsonPath);
                debug$11(("found response texts: " + (util.inspect(responseTexts))));

                var messageTexts = (_.isArray(responseTexts) ? responseTexts : [ responseTexts ]);
                messageTexts.forEach(function (messageText) {
                  if (!messageText) { return }

                  var botMsg = { sourceData: body, messageText: messageText };
                  this$1._QueueBotSays(new BotiumMockMessage_1(botMsg));
                });
              });
            }
          }

          resolve(this$1);
        }
      });
    })
  };

  SimpleRestContainer.prototype._buildRequest = function _buildRequest (msg) {
    this.view.msg = Object.assign({}, msg);
    var nonEncodedMessage = this.view.msg.messageText;
    if (this.view.msg.messageText) {
      this.view.msg.messageText = encodeURIComponent(this.view.msg.messageText);
    }
    var uri = mustache.render(this.caps[Capabilities.SIMPLEREST_URL], this.view);

    var requestOptions = {
      uri: uri,
      method: this.caps[Capabilities.SIMPLEREST_METHOD],
      json: true
    };
    if (this.view.msg.messageText) {
      this.view.msg.messageText = nonEncodedMessage;
    }
    if (this.caps[Capabilities.SIMPLEREST_HEADERS_TEMPLATE]) {
      try {
        requestOptions.headers = JSON.parse(mustache.render(this.caps[Capabilities.SIMPLEREST_HEADERS_TEMPLATE], this.view));
      } catch (err) {
        throw new Error(("composing headers from SIMPLEREST_HEADERS_TEMPLATE failed (" + (util.inspect(err)) + ")"))
      }
    }
    if (this.caps[Capabilities.SIMPLEREST_BODY_TEMPLATE]) {
      try {
        requestOptions.body = mustache.render(this.caps[Capabilities.SIMPLEREST_BODY_TEMPLATE], this.view);
      } catch (err) {
        throw new Error(("composing body from SIMPLEREST_BODY_TEMPLATE failed (" + (util.inspect(err)) + ")"))
      }
      if (!this.caps[Capabilities.SIMPLEREST_BODY_RAW]) {
        requestOptions.body = JSON.parse(requestOptions.body);
      }
    }
    return requestOptions
  };

  return SimpleRestContainer;
}(BaseContainer_1));

var debug$12 = require$$0('botium-WebSpeechContainer');






var botiumPackageRootDir$2 = findRoot();

var WebSpeechContainer_1 = (function (BaseContainer) {
  function WebSpeechContainer () {
    BaseContainer.apply(this, arguments);
  }

  if ( BaseContainer ) WebSpeechContainer.__proto__ = BaseContainer;
  WebSpeechContainer.prototype = Object.create( BaseContainer && BaseContainer.prototype );
  WebSpeechContainer.prototype.constructor = WebSpeechContainer;

  WebSpeechContainer.prototype.Validate = function Validate () {
    var this$1 = this;

    return BaseContainer.prototype.Validate.call(this).then(function () {
      this$1._AssertCapabilityExists(Capabilities.WEBSPEECH_SERVER_PORT);
      this$1._AssertCapabilityExists(Capabilities.WEBSPEECH_LANGUAGE);
    })
  };

  WebSpeechContainer.prototype.Build = function Build () {
    var this$1 = this;

    this.browserConfig = {
      WEBSPEECH_LANGUAGE: this.caps[Capabilities.WEBSPEECH_LANGUAGE],
      WEBSPEECH_PITCH: this.caps[Capabilities.WEBSPEECH_PITCH],
      WEBSPEECH_RATE: this.caps[Capabilities.WEBSPEECH_RATE],
      WEBSPEECH_VOLUME: this.caps[Capabilities.WEBSPEECH_VOLUME],
      WEBSPEECH_VOICE: this.caps[Capabilities.WEBSPEECH_VOICE]
    };

    return new Promise(function (resolve, reject) {
      async.series([
        function (baseComplete) {
          BaseContainer.prototype.Build.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        },

        function (httpServerComplete) {
          this$1.httpServer = new tinyServer(path.resolve(botiumPackageRootDir$2, 'src', 'containers', 'webspeech'));
          this$1.io = socket$1(this$1.httpServer);
          this$1.io.on('connection', function (clientSocket) {
            debug$12('browser connected to socket');
            this$1.clientSocket = clientSocket;
            this$1.clientSocket.on('disconnect', function () {
              debug$12('browser disconnecteded from socket');
              this$1.clientSocket = null;
            });
            this$1.clientSocket.on('log', function (msg) {
              debug$12(("browser log: " + msg));
            });
            this$1.clientSocket.on('botsays', function (msg) {
              debug$12(("browser botsays: " + msg));
              if (msg) {
                var botMsg = { sender: 'bot', messageText: msg };
                this$1._QueueBotSays(new BotiumMockMessage_1(botMsg));
              }
            });
            this$1.clientSocket.on('usersaid', function (msg) {
              if (this$1.usersaidResolve) {
                this$1.usersaidResolve();
                this$1.usersaidResolve = null;
              }
            });
            this$1.clientSocket.emit('startrecognize', this$1.browserConfig);

            if (this$1.connectResolve) {
              this$1.connectResolve();
              this$1.connectResolve = null;
            }
          });
          this$1.httpServer.listen(this$1.caps[Capabilities.WEBSPEECH_SERVER_PORT], function () {
            debug$12(("waiting for browser connection on port " + (this$1.caps[Capabilities.WEBSPEECH_SERVER_PORT])));
            httpServerComplete();
          }).once('error', function (err) {
            if (err.code === 'EADDRINUSE') {
              debug$12(("port " + (this$1.caps[Capabilities.WEBSPEECH_SERVER_PORT]) + " already in use."));
              httpServerComplete(err);
            }
          });
        }

      ], function (err) {
        if (err) {
          return reject(new Error(("Cannot build webspeech container: " + (util.inspect(err)))))
        }
        resolve(this$1);
      });
    })
  };

  WebSpeechContainer.prototype.Start = function Start () {
    var this$1 = this;

    this.eventEmitter.emit(Events.CONTAINER_STARTING, this);

    return new Promise(function (resolve, reject) {
      async.series([
        function (baseComplete) {
          BaseContainer.prototype.Start.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        },

        function (opnComplete) {
          if (this$1.clientSocket) {
            opnComplete();
          } else {
            this$1.connectResolve = opnComplete;

            var opnOptions = { };
            if (this$1.caps[Capabilities.WEBSPEECH_BROWSER_APP]) {
              opnOptions.app = this$1.caps[Capabilities.WEBSPEECH_BROWSER_APP];
            }

            var browserUrl = "http://127.0.0.1:" + (this$1.caps[Capabilities.WEBSPEECH_SERVER_PORT]) + "/WebSpeechContainer.html";
            debug$12(("opening browser process to point to url " + browserUrl));
            opn(browserUrl, opnOptions).then(function (cp) {
              debug$12("browser process running");
              this$1.clientProcess = cp;
            });
          }
        }

      ], function (err) {
        if (err) {
          this$1.eventEmitter.emit(Events.CONTAINER_START_ERROR, this$1, err);
          return reject(new Error(("Start failed " + (util.inspect(err)))))
        }
        this$1.eventEmitter.emit(Events.CONTAINER_STARTED, this$1);
        resolve(this$1);
      });
    })
  };

  WebSpeechContainer.prototype.UserSays = function UserSays (mockMsg) {
    var this$1 = this;

    return new Promise(function (resolve, reject) {
      if (this$1.clientSocket) {
        this$1.usersaidResolve = function () {
          this$1.eventEmitter.emit(Events.MESSAGE_SENTTOBOT, this$1, mockMsg);
          resolve(this$1);
        };
        this$1.clientSocket.emit('usersays', this$1.browserConfig, mockMsg);
      } else {
        this$1.eventEmitter.emit(Events.MESSAGE_SENDTOBOT_ERROR, this$1, 'browser connection not online');
        reject(new Error('browser connection not online'));
      }
    })
  };

  WebSpeechContainer.prototype.Stop = function Stop () {
    var this$1 = this;

    this.eventEmitter.emit(Events.CONTAINER_STOPPING, this);

    return new Promise(function (resolve, reject) {
      async.series([
        function (baseComplete) {
          BaseContainer.prototype.Stop.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        }

      ], function (err) {
        if (err) {
          this$1.eventEmitter.emit(Events.CONTAINER_STOP_ERROR, this$1, err);
          return reject(new Error(("Stop failed " + (util.inspect(err)))))
        }
        this$1.eventEmitter.emit(Events.CONTAINER_STOPPED, this$1);
        resolve(this$1);
      });
    })
  };

  WebSpeechContainer.prototype.Clean = function Clean () {
    var this$1 = this;

    this.eventEmitter.emit(Events.CONTAINER_CLEANING, this);

    return new Promise(function (resolve, reject) {
      async.series([
        function (baseComplete) {
          BaseContainer.prototype.Clean.call(this$1).then(function () { return baseComplete(); }).catch(baseComplete);
        },

        function (httpServerStopped) {
          this$1.io = null;
          if (this$1.clientSocket) {
            if (this$1.caps[Capabilities.WEBSPEECH_CLOSEBROWSER]) {
              this$1.clientSocket.emit('close');
            }
            this$1.clientSocket.disconnect(true);
            this$1.clientSocket = null;
          }
          if (this$1.httpServer) {
            debug$12('closing http server');
            this$1.httpServer.close(function () {
              debug$12('stopped browser listening.');
              this$1.httpServer = null;
              httpServerStopped();
            });
          } else {
            httpServerStopped();
          }
        },

        function (clientProcessStopped) {
          if (this$1.caps[Capabilities.WEBSPEECH_CLOSEBROWSER]) {
            if (this$1.clientProcess) {
              debug$12('killing browser process');
              this$1.clientProcess.kill();
            }
          }
          this$1.clientProcess = null;
          clientProcessStopped();
        }

      ], function (err) {
        if (err) {
          this$1.eventEmitter.emit(Events.CONTAINER_CLEAN_ERROR, this$1, err);
          return reject(new Error(("Cleanup failed " + (util.inspect(err)))))
        }
        this$1.eventEmitter.emit(Events.CONTAINER_CLEANED, this$1);
        resolve(this$1);
      });
    })
  };

  return WebSpeechContainer;
}(BaseContainer_1));

var InProcessContainer_1 = (function (BaseContainer) {
  function InProcessContainer () {
    BaseContainer.apply(this, arguments);
  }

  if ( BaseContainer ) InProcessContainer.__proto__ = BaseContainer;
  InProcessContainer.prototype = Object.create( BaseContainer && BaseContainer.prototype );
  InProcessContainer.prototype.constructor = InProcessContainer;

  InProcessContainer.prototype.UserSays = function UserSays (mockMsg) {
    this.eventEmitter.emit(Events.MESSAGE_SENTTOBOT, this, mockMsg);
    return Promise.resolve(this)
  };
  InProcessContainer.prototype.InjectBotSays = function InjectBotSays (botMsg) {
    this._QueueBotSays(new BotiumMockMessage_1(botMsg));
  };

  return InProcessContainer;
}(BaseContainer_1));

var debug$13 = require$$0('botium-PluginConnectorContainer');





var PluginConnectorContainer_1 = (function (BaseContainer) {
  function PluginConnectorContainer () {
    BaseContainer.apply(this, arguments);
  }

  if ( BaseContainer ) PluginConnectorContainer.__proto__ = BaseContainer;
  PluginConnectorContainer.prototype = Object.create( BaseContainer && BaseContainer.prototype );
  PluginConnectorContainer.prototype.constructor = PluginConnectorContainer;

  PluginConnectorContainer.prototype.Validate = function Validate () {
    var this$1 = this;

    return BaseContainer.prototype.Validate.call(this).then(function () {
      var tryLoadPackage = "botium-connector-" + (this$1.caps[Capabilities.CONTAINERMODE]);
      try {
        this$1.plugin = commonjsRequire(tryLoadPackage);
        debug$13(("Botium plugin " + tryLoadPackage + " loaded"));
      } catch (err) {
        throw new Error(("Loading Botium plugin " + tryLoadPackage + " failed, try \"npm install " + tryLoadPackage + "\" - " + (util.inspect(err))))
      }
      if (!this$1.plugin.PluginVersion || !this$1.plugin.PluginClass) {
        throw new Error(("Invalid Botium plugin " + tryLoadPackage + ", expected PluginVersion, PluginClass fields"))
      }
      this$1.pluginInstance = new this$1.plugin.PluginClass({
        queueBotSays: function (msg) { return this$1._QueueBotSays(msg); },
        caps: this$1.caps,
        sources: this$1.sources,
        envs: this$1.envs
      });
      if (!this$1.pluginInstance.UserSays) {
        throw new Error(("Invalid Botium plugin " + tryLoadPackage + ", expected UserSays function"))
      }
      return this$1.pluginInstance.Validate()
    })
  };

  PluginConnectorContainer.prototype.Build = function Build () {
    var this$1 = this;

    try {
      return BaseContainer.prototype.Build.call(this).then(function () { return this$1.pluginInstance.Build ? (this$1.pluginInstance.Build() || Promise.resolve()) : Promise.resolve(); }).then(function () { return this$1; })
    } catch (err) {
      return Promise.reject(new Error(("Build - Botium plugin failed: " + (util.inspect(err)))))
    }
  };

  PluginConnectorContainer.prototype.Start = function Start () {
    var this$1 = this;

    this.eventEmitter.emit(Events.CONTAINER_STARTING, this);

    try {
      return BaseContainer.prototype.Start.call(this).then(function () { return this$1.pluginInstance.Start ? (this$1.pluginInstance.Start() || Promise.resolve()) : Promise.resolve(); }).then(function () {
        this$1.eventEmitter.emit(Events.CONTAINER_STARTED, this$1);
        return this$1
      }).catch(function (err) {
        this$1.eventEmitter.emit(Events.CONTAINER_START_ERROR, this$1, err);
        throw err
      })
    } catch (err) {
      this.eventEmitter.emit(Events.CONTAINER_START_ERROR, this, err);
      return Promise.reject(new Error(("Start - Botium plugin failed: " + (util.inspect(err)))))
    }
  };

  PluginConnectorContainer.prototype.UserSays = function UserSays (mockMsg) {
    var this$1 = this;

    try {
      return (this.pluginInstance.UserSays(mockMsg) || Promise.resolve()).then(function () {
        this$1.eventEmitter.emit(Events.MESSAGE_SENTTOBOT, this$1, mockMsg);
        return this$1
      })
    } catch (err) {
      return Promise.reject(new Error(("UserSays - Botium plugin failed: " + (util.inspect(err)))))
    }
  };

  PluginConnectorContainer.prototype.Stop = function Stop () {
    var this$1 = this;

    this.eventEmitter.emit(Events.CONTAINER_STOPPING, this);

    try {
      return BaseContainer.prototype.Stop.call(this).then(function () { return this$1.pluginInstance.Stop ? (this$1.pluginInstance.Stop() || Promise.resolve()) : Promise.resolve(); }).then(function () {
        this$1.eventEmitter.emit(Events.CONTAINER_STOPPED, this$1);
        return this$1
      }).catch(function (err) {
        this$1.eventEmitter.emit(Events.CONTAINER_STOP_ERROR, this$1, err);
        throw err
      })
    } catch (err) {
      this.eventEmitter.emit(Events.CONTAINER_STOP_ERROR, this, err);
      return Promise.reject(new Error(("Stop - Botium plugin failed: " + (util.inspect(err)))))
    }
  };

  PluginConnectorContainer.prototype.Clean = function Clean () {
    var this$1 = this;

    this.eventEmitter.emit(Events.CONTAINER_CLEANING, this);

    try {
      return (this.pluginInstance.Clean ? (this.pluginInstance.Clean() || Promise.resolve()) : Promise.resolve()).then(function () { return BaseContainer.prototype.Clean.call(this$1); }).then(function () {
        this$1.eventEmitter.emit(Events.CONTAINER_CLEANED, this$1);
        return this$1
      }).catch(function (err) {
        this$1.eventEmitter.emit(Events.CONTAINER_CLEAN_ERROR, this$1, err);
        throw err
      })
    } catch (err) {
      this.eventEmitter.emit(Events.CONTAINER_CLEAN_ERROR, this, err);
      return Promise.reject(new Error(("Clean - Botium plugin failed: " + (util.inspect(err)))))
    }
  };

  return PluginConnectorContainer;
}(BaseContainer_1));

var debug$14 = require$$0('botium-BotDriver');








var BotDriver_1 = (function () {
  function BotDriver (caps, sources, env) {
  var this$1 = this;
  if ( caps === void 0 ) caps = {};
  if ( sources === void 0 ) sources = {};
  if ( env === void 0 ) env = {};

    this.eventEmitter = new events();

    this.caps = Object.assign({}, Defaults.Capabilities);
    this.sources = Object.assign({}, Defaults.Sources);
    this.envs = Object.assign({}, Defaults.Envs);

    var loadConfigFile = function (filename) {
      try {
        var configJson = JSON.parse(fs.readFileSync(filename));
        if (configJson.botium) {
          this$1.caps = Object.assign(this$1.caps, configJson.botium.Capabilities);
          this$1.sources = Object.assign(this$1.sources, configJson.botium.Sources);
          this$1.envs = Object.assign(this$1.envs, configJson.botium.Envs);
          debug$14(("Loaded Botium configuration file " + filename));
        } else {
          debug$14(("Botium configuration file " + filename + " contains no botium configuration. Ignored."));
        }
      } catch (err) {
        throw new Error(("FAILED: loading Botium configuration file " + filename + ": " + (util.inspect(err))))
      }
    };

    if (fs.existsSync('./botium.json')) {
      loadConfigFile('./botium.json');
    }

    var botiumConfigEnv = process.env['BOTIUM_CONFIG'];
    if (botiumConfigEnv) {
      if (fs.existsSync(botiumConfigEnv)) {
        loadConfigFile(botiumConfigEnv);
      } else {
        throw new Error(("FAILED: Botium configuration file " + botiumConfigEnv + " not available"))
      }
    }

    var capsToTest = Object.keys(Capabilities);
    var sourcesToTest = Object.keys(Source);

    Object.keys(process.env).filter(function (e) { return e.startsWith('BOTIUM_'); }).forEach(function (element) {
      var elementToTest = element.replace(/^BOTIUM_/, '');
      if (capsToTest.includes(elementToTest)) {
        this$1.caps[elementToTest] = process.env[element];
        debug$14('Changed capability : ' + elementToTest + ' to : ' + process.env[element] + ' using environment variables.');
      }
      if (sourcesToTest.includes(elementToTest)) {
        this$1.sources[elementToTest] = process.env[element];
        debug$14('Changed capability : ' + elementToTest + ' to : ' + process.env[element] + ' using environment variables.');
      }
      if (element.startsWith('BOTIUM_ENV_')) {
        var envName = element.replace(/^BOTIUM_ENV_/, '');
        this$1.envs[envName] = process.env[element];
        debug$14('Changed env : ' + envName + ' to : ' + process.env[element] + ' using environment variables.');
      }
    });

    this.caps = Object.assign(this.caps, caps);
    this.sources = Object.assign(this.sources, sources);
  }

  BotDriver.prototype.on = function on (event, listener) {
    this.eventEmitter.on(event, listener);
    return this
  };

  BotDriver.prototype.setCapabilities = function setCapabilities (caps) {
    this.caps = Object.assign(this.caps, caps);
    return this
  };

  BotDriver.prototype.setCapability = function setCapability (cap, value) {
    this.caps[cap] = value;
    return this
  };

  BotDriver.prototype.setSources = function setSources (sources) {
    this.sources = Object.assign(this.sources, sources);
    return this
  };

  BotDriver.prototype.setSource = function setSource (source, value) {
    this.sources[source] = value;
    return this
  };

  BotDriver.prototype.setEnvs = function setEnvs (envs) {
    this.envs = Object.assign(this.envs, envs);
    return this
  };

  BotDriver.prototype.setEnv = function setEnv (name, value) {
    this.envs[name] = value;
    return this
  };

  BotDriver.prototype.BuildFluent = function BuildFluent () {
    this.Fluent = new Fluent_1(this);
    return this.Fluent
  };

  BotDriver.prototype.Build = function Build () {
    var this$1 = this;

    debug$14(("Build - Capabilites: " + (util.inspect(this.caps))));
    debug$14(("Build - Sources : " + (util.inspect(this.sources))));
    debug$14(("Build - Envs : " + (util.inspect(this.envs))));
    this.eventEmitter.emit(Events.CONTAINER_BUILDING);

    return new Promise(function (resolve, reject) {
      var repo = null;
      var container = null;

      async.series([

        function (driverValidated) {
          this$1._validate()
            .then(function () { return driverValidated(); })
            .catch(driverValidated);
        },

        function (repoValidated) {
          try {
            repo = this$1._getRepo();
          } catch (err) {
            return repoValidated(err)
          }
          repo.Validate().then(function () { return repoValidated(); }).catch(repoValidated);
        },

        function (repoPrepared) {
          repo.Prepare().then(function () { return repoPrepared(); }).catch(repoPrepared);
        },

        function (containerValidated) {
          try {
            container = this$1._getContainer(repo);
          } catch (err) {
            return containerValidated(err)
          }
          container.Validate().then(function () { return containerValidated(); }).catch(containerValidated);
        },

        function (containerBuilt) {
          container.Build().then(function () { return containerBuilt(); }).catch(containerBuilt);
        }

      ], function (err) {
        if (err) {
          debug$14(("BotDriver Build error: " + err));
          this$1.eventEmitter.emit(Events.CONTAINER_BUILD_ERROR, err);
          return reject(err)
        }
        this$1.eventEmitter.emit(Events.CONTAINER_BUILT, container);
        resolve(container);
      });
    })
  };

  BotDriver.prototype.BuildCompiler = function BuildCompiler () {
    debug$14(("BuildCompiler: Capabilites: " + (util.inspect(this.caps))));
    try {
      var compiler = new ScriptingProvider_1(this.caps);
      compiler.Build();
      return compiler
    } catch (err) {
      debug$14(("BotDriver BuildCompiler error: " + err));
      throw err
    }
  };

  /* Private Functions */

  BotDriver.prototype._validate = function _validate () {
    var this$1 = this;

    return new Promise(function (resolve, reject) {
      if (!this$1.caps[Capabilities.PROJECTNAME]) {
        throw new Error(("Capability property " + (Capabilities.PROJECTNAME) + " not set"))
      }
      if (!this$1.caps[Capabilities.TEMPDIR]) {
        throw new Error(("Capability property " + (Capabilities.TEMPDIR) + " not set"))
      }

      async.series([
        function (tempdirCreated) {
          this$1.tempDirectory = path.resolve(process.cwd(), this$1.caps[Capabilities.TEMPDIR], slug(((this$1.caps[Capabilities.PROJECTNAME]) + " " + (moment().format('YYYYMMDD HHmmss')) + " " + (randomatic('Aa0', 5)))));

          mkdirp(this$1.tempDirectory, function (err) {
            if (err) {
              return tempdirCreated(new Error(("Unable to create temp directory " + (this$1.tempDirectory) + ": " + err)))
            }
            tempdirCreated();
          });
        }

      ], function (err) {
        if (err) {
          return reject(err)
        }
        resolve(this$1);
      });
    })
  };

  BotDriver.prototype._getRepo = function _getRepo () {
    if (this.caps[Capabilities.BOTIUMGRIDURL]) {
      var NoRepo = NoRepo_1;
      return new NoRepo(this.tempDirectory, this.sources)
    }
    if (this.sources[Source.GITURL]) {
      var GitRepo = GitRepo_1;
      return new GitRepo(this.tempDirectory, this.sources)
    }
    if (this.sources[Source.LOCALPATH]) {
      var LocalRepo = LocalRepo_1;
      return new LocalRepo(this.tempDirectory, this.sources)
    }
    throw new Error(("No Repo provider found for Sources " + (util.inspect(this.sources))))
  };

  BotDriver.prototype._getContainer = function _getContainer (repo) {
    if (this.caps[Capabilities.BOTIUMGRIDURL]) {
      var GridContainer = GridContainer_1;
      return new GridContainer(this.eventEmitter, this.tempDirectory, repo, this.caps, this.envs)
    }
    if (!this.caps[Capabilities.CONTAINERMODE]) {
      throw new Error(("Capability '" + (Capabilities.CONTAINERMODE) + "' missing"))
    }
    if (this.caps[Capabilities.CONTAINERMODE] === 'docker') {
      var DockerContainer = DockerContainer_1;
      return new DockerContainer(this.eventEmitter, this.tempDirectory, repo, this.caps, this.envs)
    }
    if (this.caps[Capabilities.CONTAINERMODE] === 'fbdirect') {
      var FbContainer = FbContainer_1;
      return new FbContainer(this.eventEmitter, this.tempDirectory, repo, this.caps, this.envs)
    }
    if (this.caps[Capabilities.CONTAINERMODE] === 'watsonconversation') {
      var WatsonConversationContainer = WatsonConversationContainer_1;
      return new WatsonConversationContainer(this.eventEmitter, this.tempDirectory, repo, this.caps, this.envs)
    }
    if (this.caps[Capabilities.CONTAINERMODE] === 'simplerest') {
      var SimpleRestContainer = SimpleRestContainer_1;
      return new SimpleRestContainer(this.eventEmitter, this.tempDirectory, repo, this.caps, this.envs)
    }
    if (this.caps[Capabilities.CONTAINERMODE] === 'webspeech') {
      var WebSpeechContainer = WebSpeechContainer_1;
      return new WebSpeechContainer(this.eventEmitter, this.tempDirectory, repo, this.caps, this.envs)
    }
    if (this.caps[Capabilities.CONTAINERMODE] === 'inprocess') {
      var InProcessContainer = InProcessContainer_1;
      return new InProcessContainer(this.eventEmitter, this.tempDirectory, repo, this.caps, this.envs)
    }
    var PluginConnectorContainer = PluginConnectorContainer_1;
    return new PluginConnectorContainer(this.eventEmitter, this.tempDirectory, repo, this.caps, this.envs)
  };

  return BotDriver;
}());

var botiumCore = {
  BotDriver: BotDriver_1,
  Capabilities: Capabilities,
  Source: Source
};
var botiumCore_1 = botiumCore.BotDriver;
var botiumCore_2 = botiumCore.Capabilities;
var botiumCore_3 = botiumCore.Source;

export default botiumCore;
export { botiumCore_1 as BotDriver, botiumCore_2 as Capabilities, botiumCore_3 as Source };
//# sourceMappingURL=botium-es.js.map
